{
    "docs": [
        {
            "location": "/", 
            "text": "Web dedicada al scripting en PS (PowerShell) en MS Win, especialmente en servidores con Active Directory y Exchange.", 
            "title": "Inicio"
        }, 
        {
            "location": "/sintaxis/array/", 
            "text": "Un array contiene una lista de elementos de datos. Una diferencia frente a otros lenguajes de programaci\u00f3n es que los elementos del array no tienen porque ser del mismo tipo a no ser que se defina el tipo de datos que alberga de forma explicita (\nstrongly typed\n).\n\n\nCreando un array\n\n\nFuente:\n \narray.ps1\n\n\nPara crear un array definimos cada elemento separado por \n,\n.\n\n\n$myArray = 1,\nHola\n,3.5,\nMundo\n\n$myArray    \n\n\n\n\nO usando la sintaxis explicita:\n\n\n$myArray = @(1,\nHola\n,3.5,\nMundo\n)\n\n\n\n\nPodemos el valor de un elemento determinado por su posici\u00f3n \n$myArray[1]\n contiene la cadena \"Hola\" (\nla primera posici\u00f3n de un array es la 0\n).\n\n\nPara distribuir los elementos en variables individuales:\n\n\n$var1,$var2,$var3 = $myArray\n\n\n\n\nCon un array de enteros (int) podemos usar el operador de rango para crear una secuencia de n\u00fameros ordenada\n\n\n$myArray = 1,2,3,4,5,6,7\n$myArray = (1..7)\n\n\n\n\nPara obtener el n\u00famero de elementos usamos el miembro del objeto array length: \n$myArray.length\n. \n\n\nTambi\u00e9n podemos crear arrays multidimensionales, por ejemplo un array de 2x3:\n\n\n$myMultiArray = @(\n    (1,2,3),\n    (40,50,60)\n)\n\n\n\n\nA\u00f1adir valores a un array\n\n\nPara a\u00f1adir nuevos valores al array** usamos el operador \n+=\n.\n\n\n$myArray += 12\n$countries += 'Hola'\n\n\n\n\nObtener elementos de un array\n\n\n$myArray\n: Retorna todos los elementos del array, arriba ya hemos visto como acceder a elementos individuales por su posici\u00f3n.\n\n\nPara obtener un rango de elementos usamos por ejemplo \n$myArray[4..6]\n para obtener los valores comprendidos entre la posici\u00f3n 4 y la 6.\n\n\nPara \n\n\nArrays Asociativos o Hashtable\n\n\n$myHashtable = @{ Key1 = \nValue1\n; \nKey 2\n = 1,2,3 }\n\n\n\n\nArrays de objetos\n\n\nFuente:\n \narray_objects.ps1\n\n\nCuando se crea un array sin especificar el tipo de datos que alberga PS crea el array como un array de objetos. Nosotros tambi\u00e9n podemos crear un array de objetos usando el cmdlet \nNew-Object\n.\n\n\n# Creamos un array de objetos de tipo string\n$myArray = New-Object string[] 10\n$myArray[5] = \nHola\n \n# Permite hacer esto\n$myArray[1] = 12\n\n$myArray\n\n$myArray.gettype()\n\n\n\n\nFuente:\n \narray_obj_strong_typed.ps1\n\n\nSi queremos crear un array cuyo tipo de dato base sea inmutable podemos usar la siguiente sintaxis:\n\n\n$myList = New-Object Collections.Generic.List[Int]\n$myList.Add(10)\n# Esto produce error\n$myList.Add(\nHola\n)\n\n\n\n\nFuente:\n \narray_get_process.ps1\n\n\nPara almacenar la salida de un comando que genera una lista (\nGet-Process\n) usamos la una asignaci\u00f3n a una varible, el siguiente ejemplo muestra todos los procesos corriendo un nuestro ordenador.\n\n\n$myArray = Get-Process\n$myArray\n\n\n\n\nArray de objetos creados a medida\n\n\nFuente:\n \narray_custom_obj.ps1\n\n\nPowerShell a pesar de ser un lenguaje interpretado demuestra ser muy avanzando ya que permite crear objetos a medida y jugar con ellos en un array.\n\n\n# Creamos un objeto propio\n$myObject = New-Object System.Object\n\n# A\u00f1adimos nuestras propiedades al objeto\n$myObject | Add-Member -type NoteProperty -name Name -Value \nIker_PC\n\n$myObject | Add-Member -type NoteProperty -name Manufacturer -Value \nDell\n\n$myObject | Add-Member -type NoteProperty -name ProcessorSpeed -Value \n3 Ghz\n\n$myObject | Add-Member -type NoteProperty -name Memory -Value \n6 GB\n\n\n$myObject\n\n\nMemory is: \n+$myObject.Memory\n\nif ( (Test-Connection $myObject.Name -quiet) -eq $false)\n{\n    $myObject.Name + \n ICMP echo request error\n\n}\nelse \n{\n    $myObject.Name + \n ICMP echo request ok\n\n}\n\n# Modificamos una propiedad de un objeto\n$myObject.Manufacturer = \nHP\n\n$myObject\n\n\n\n\nAhora creamos un nuevo objeto y a\u00f1adimos ambos a un array:\n\n\n# Creamos un array vacio\n$myArray = @()\n$myArray += $myObject\n\n#Definimos un nuevo objeto\n$myObject2 = New-Object System.Object\n$myObject2 | Add-Member -type NoteProperty -name Name -Value \nAsier_PC\n\n$myObject2 | Add-Member -type NoteProperty -name Manufacturer -Value \nAcer\n\n$myObject2 | Add-Member -type NoteProperty -name ProcessorSpeed -Value \n3 Ghz\n\n$myObject2 | Add-Member -type NoteProperty -name Memory -Value \n4 GB\n\n\n$myArray += $myObject2\n\n$myArray | Select-Object name\n\n\n\n\nFuente:\n \narray_custom_obj_alt.ps1\n\n\nPodemos crear objetos a medida creando las propiedades como un array para el objeto de tipo PSObject.\n\n\nRecursos arrays\n\n\n\n\nhttps://ss64.com/ps/syntax-arrays.html\n\n\nGet-Blog : Ryan\u2019s PowerShell Blog \nCreating an Array of Custom Objects in Powershell\n.\n\n\nNew-Object\n.\n\n\nWindows PowerShell Cookbook by Lee Holmes\n.\n\n\nUsing the Get-Process Cmdlet\n.\n\n\nGet-Process\n.\n\n\nTest-Connection\n: Sends ICMP echo request packets (\"pings\") to one or more computers.\n\n\nPowershell: Array of Custom Objects (PSCustomObject/PSObject)\n.\n\n\nPSObject Class\n.", 
            "title": "Arrays"
        }, 
        {
            "location": "/sintaxis/array/#creando-un-array", 
            "text": "Fuente:   array.ps1  Para crear un array definimos cada elemento separado por  , .  $myArray = 1, Hola ,3.5, Mundo \n$myArray      O usando la sintaxis explicita:  $myArray = @(1, Hola ,3.5, Mundo )  Podemos el valor de un elemento determinado por su posici\u00f3n  $myArray[1]  contiene la cadena \"Hola\" ( la primera posici\u00f3n de un array es la 0 ).  Para distribuir los elementos en variables individuales:  $var1,$var2,$var3 = $myArray  Con un array de enteros (int) podemos usar el operador de rango para crear una secuencia de n\u00fameros ordenada  $myArray = 1,2,3,4,5,6,7\n$myArray = (1..7)  Para obtener el n\u00famero de elementos usamos el miembro del objeto array length:  $myArray.length .   Tambi\u00e9n podemos crear arrays multidimensionales, por ejemplo un array de 2x3:  $myMultiArray = @(\n    (1,2,3),\n    (40,50,60)\n)", 
            "title": "Creando un array"
        }, 
        {
            "location": "/sintaxis/array/#anadir-valores-a-un-array", 
            "text": "Para a\u00f1adir nuevos valores al array** usamos el operador  += .  $myArray += 12\n$countries += 'Hola'", 
            "title": "A\u00f1adir valores a un array"
        }, 
        {
            "location": "/sintaxis/array/#obtener-elementos-de-un-array", 
            "text": "$myArray : Retorna todos los elementos del array, arriba ya hemos visto como acceder a elementos individuales por su posici\u00f3n.  Para obtener un rango de elementos usamos por ejemplo  $myArray[4..6]  para obtener los valores comprendidos entre la posici\u00f3n 4 y la 6.  Para", 
            "title": "Obtener elementos de un array"
        }, 
        {
            "location": "/sintaxis/array/#arrays-asociativos-o-hashtable", 
            "text": "$myHashtable = @{ Key1 =  Value1 ;  Key 2  = 1,2,3 }", 
            "title": "Arrays Asociativos o Hashtable"
        }, 
        {
            "location": "/sintaxis/array/#arrays-de-objetos", 
            "text": "Fuente:   array_objects.ps1  Cuando se crea un array sin especificar el tipo de datos que alberga PS crea el array como un array de objetos. Nosotros tambi\u00e9n podemos crear un array de objetos usando el cmdlet  New-Object .  # Creamos un array de objetos de tipo string\n$myArray = New-Object string[] 10\n$myArray[5] =  Hola  \n# Permite hacer esto\n$myArray[1] = 12\n\n$myArray\n\n$myArray.gettype()  Fuente:   array_obj_strong_typed.ps1  Si queremos crear un array cuyo tipo de dato base sea inmutable podemos usar la siguiente sintaxis:  $myList = New-Object Collections.Generic.List[Int]\n$myList.Add(10)\n# Esto produce error\n$myList.Add( Hola )  Fuente:   array_get_process.ps1  Para almacenar la salida de un comando que genera una lista ( Get-Process ) usamos la una asignaci\u00f3n a una varible, el siguiente ejemplo muestra todos los procesos corriendo un nuestro ordenador.  $myArray = Get-Process\n$myArray", 
            "title": "Arrays de objetos"
        }, 
        {
            "location": "/sintaxis/array/#array-de-objetos-creados-a-medida", 
            "text": "Fuente:   array_custom_obj.ps1  PowerShell a pesar de ser un lenguaje interpretado demuestra ser muy avanzando ya que permite crear objetos a medida y jugar con ellos en un array.  # Creamos un objeto propio\n$myObject = New-Object System.Object\n\n# A\u00f1adimos nuestras propiedades al objeto\n$myObject | Add-Member -type NoteProperty -name Name -Value  Iker_PC \n$myObject | Add-Member -type NoteProperty -name Manufacturer -Value  Dell \n$myObject | Add-Member -type NoteProperty -name ProcessorSpeed -Value  3 Ghz \n$myObject | Add-Member -type NoteProperty -name Memory -Value  6 GB \n\n$myObject Memory is:  +$myObject.Memory\n\nif ( (Test-Connection $myObject.Name -quiet) -eq $false)\n{\n    $myObject.Name +   ICMP echo request error \n}\nelse \n{\n    $myObject.Name +   ICMP echo request ok \n}\n\n# Modificamos una propiedad de un objeto\n$myObject.Manufacturer =  HP \n$myObject  Ahora creamos un nuevo objeto y a\u00f1adimos ambos a un array:  # Creamos un array vacio\n$myArray = @()\n$myArray += $myObject\n\n#Definimos un nuevo objeto\n$myObject2 = New-Object System.Object\n$myObject2 | Add-Member -type NoteProperty -name Name -Value  Asier_PC \n$myObject2 | Add-Member -type NoteProperty -name Manufacturer -Value  Acer \n$myObject2 | Add-Member -type NoteProperty -name ProcessorSpeed -Value  3 Ghz \n$myObject2 | Add-Member -type NoteProperty -name Memory -Value  4 GB \n\n$myArray += $myObject2\n\n$myArray | Select-Object name  Fuente:   array_custom_obj_alt.ps1  Podemos crear objetos a medida creando las propiedades como un array para el objeto de tipo PSObject.", 
            "title": "Array de objetos creados a medida"
        }, 
        {
            "location": "/sintaxis/array/#recursos-arrays", 
            "text": "https://ss64.com/ps/syntax-arrays.html  Get-Blog : Ryan\u2019s PowerShell Blog  Creating an Array of Custom Objects in Powershell .  New-Object .  Windows PowerShell Cookbook by Lee Holmes .  Using the Get-Process Cmdlet .  Get-Process .  Test-Connection : Sends ICMP echo request packets (\"pings\") to one or more computers.  Powershell: Array of Custom Objects (PSCustomObject/PSObject) .  PSObject Class .", 
            "title": "Recursos arrays"
        }, 
        {
            "location": "/sintaxis/for/", 
            "text": "Los bucles \nfor\n ejecutan un bloque de comandos n veces bas\u00e1ndose en una condici\u00f3n de parada.\n\n\nSintaxis:\n\n\nfor (init; condition; repeat) \n{\n    # command_block\n    # ...\n}\n\n\n\n\ninit\n se usa normalmente para inicializar una variable a un valor para usarla dentro del bucle como contador de iteraciones, \ncondition\n suele tener la condici\u00f3n de parada del bucle y \nrepeat\n contiene comandos, normalmente cuando se usa como contador contendr\u00e1 como se incrementa la variable inicializada en \ninit\n como en este primer ejemplo. \n\n\nFor b\u00e1sico\n\n\nFuente:\n \narray.ps1\n\n\nLa variable \n$i\n se inicializa con el valor 1, mientr\u00e1s \n$i\n sea menor o igual que 10 (ver \ncomparison operators\n su valor se incrementar\u00e1 y ejecutar\u00e1 el bloque de comandos entre llaves. \n\n\nPS\n for($i=1; $i -le 10; $i++){$i} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\nBucle For con Arrays\n\n\nFuente:\n \nfor_array.ps1\n\n\nProbablemente tiene m\u00e1s sentido recorrer un array usando \nForEach\n pero es muy com\u00fan hacerlo tambi\u00e9n con contador para recorrer cada elemento del array conociendo su longitud:\n\n\n$myarray = @(\ntest1\n, \ntest2\n, \ntest3\n)\nfor ($i=0; $i -lt $myarray.length; $i++) \n{\n    $myarray[$i]\n}\n\n\n\n\nAlgo m\u00e1s avanzando es hacerlo con una tuber\u00eda (\npipe\n).\n\n\n$myarray |foreach { $_ }\n\n\n\n\nRecursos\n\n\n\n\nhttps://ss64.com/ps/for.html\n.\n\n\n[comparison operators](https://ss64.com/ps/syntax-compare.html.", 
            "title": "For"
        }, 
        {
            "location": "/sintaxis/for/#for-basico", 
            "text": "Fuente:   array.ps1  La variable  $i  se inicializa con el valor 1, mientr\u00e1s  $i  sea menor o igual que 10 (ver  comparison operators  su valor se incrementar\u00e1 y ejecutar\u00e1 el bloque de comandos entre llaves.   PS  for($i=1; $i -le 10; $i++){$i} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10", 
            "title": "For b\u00e1sico"
        }, 
        {
            "location": "/sintaxis/for/#bucle-for-con-arrays", 
            "text": "Fuente:   for_array.ps1  Probablemente tiene m\u00e1s sentido recorrer un array usando  ForEach  pero es muy com\u00fan hacerlo tambi\u00e9n con contador para recorrer cada elemento del array conociendo su longitud:  $myarray = @( test1 ,  test2 ,  test3 )\nfor ($i=0; $i -lt $myarray.length; $i++) \n{\n    $myarray[$i]\n}  Algo m\u00e1s avanzando es hacerlo con una tuber\u00eda ( pipe ).  $myarray |foreach { $_ }", 
            "title": "Bucle For con Arrays"
        }, 
        {
            "location": "/sintaxis/for/#recursos", 
            "text": "https://ss64.com/ps/for.html .  [comparison operators](https://ss64.com/ps/syntax-compare.html.", 
            "title": "Recursos"
        }, 
        {
            "location": "/sintaxis/foreach/", 
            "text": "ForEach\n permite crear bucles que ejecutan una serie de rutinas de forma iterativa.\n\n\nSintaxis:\n\n\nForEach (item In collection) {ScriptBlock}\n\n\n\n\nRecorre una colecci\u00f3n de elementos y en cada iteraci\u00f3n nos proporciona el siguiente elemento (item) de la colecci\u00f3n (collection).\n\n\nForEach con arrays\n\n\nforeach_array.ps1\n\n\nDeclaramos tres variables que contienen n\u00fameros enteros:\n\n\n$a = 1 \n$b = 2\n$c = 3\n\n\n\n\nCon las tres variables componemos un array:\n\n\n$d = $a,$b,$c\n\n\n\n\nEn el caso de arrays de enteros podemos usar el operador de rango para crear una secuencia ordenada de n\u00fameros, para el ejemplo superior hubiese sido equivalente crearlo as\u00ed:\n\n\n$d = 1..3\n\n\n\n\nPodemos acceder a cada elemento del array \n\n\nEnlaces", 
            "title": "Foreach"
        }, 
        {
            "location": "/sintaxis/foreach/#foreach-con-arrays", 
            "text": "foreach_array.ps1  Declaramos tres variables que contienen n\u00fameros enteros:  $a = 1 \n$b = 2\n$c = 3  Con las tres variables componemos un array:  $d = $a,$b,$c  En el caso de arrays de enteros podemos usar el operador de rango para crear una secuencia ordenada de n\u00fameros, para el ejemplo superior hubiese sido equivalente crearlo as\u00ed:  $d = 1..3  Podemos acceder a cada elemento del array", 
            "title": "ForEach con arrays"
        }, 
        {
            "location": "/sintaxis/foreach/#enlaces", 
            "text": "", 
            "title": "Enlaces"
        }, 
        {
            "location": "/sintaxis/function/", 
            "text": "Las funciones permiten agrupar comandos con un prop\u00f3sito y ejecutarlo desde cualquier parte de nuestro programa invoc\u00e1ndola por su nombre, evitamos repetir los mismos comandos una y otra vez cuando queremos repetir una operaci\u00f3n. Encapsulando la l\u00f3gica de la aplicaci\u00f3n en una funci\u00f3n adem\u00e1s fomenta la reutilizaci\u00f3n del c\u00f3digo en otros scripts y la legibilidad para entender su funcionamiento.\n\n\nPara crear una funci\u00f3n comenzamos con la palabra clave \nFunction\n para declararla seguida del nombre de la funci\u00f3n que queramos darle, como \nbuena pr\u00e1ctica\n los manuales recomiendan usar una combinaci\u00f3n de verbo-nombre, podemos incluso obtener una lista est\u00e1ndar de verbos que usa PS.  \n\n\nGet-Command -CommandType cmdlet | Group-Object -Property Verb | Sort-Object -Property count -Descending\n\n\n\n\nFunci\u00f3n b\u00e1sica\n\n\nFuente:\n \nWrite-HolaMundo.ps1\n\n\nEl siguiente ejemplo ilustra una funci\u00f3n super sencilla, cada vez que invocamos a la funci\u00f3n por su nombre (una funci\u00f3n debe \"llamarse\" para que ejecute sus comandos) ejecuta las l\u00edneas de comandos encerradas entre las llaves \n{ }\n.   \n\n\nFunction Write-HolaMundo\n{\n    \nHola\n\n    \nMundo\n\n}\n\nWrite-HolaMundo\n# Podemos invocar la funci\u00f3n por su nombre tantas veces queramos.\nWrite-HolaMundo\n\n\n\n\nFunci\u00f3n para obtener la versi\u00f3n del sistema operativo\n\n\nFuente:\n \nGet-OperatingSystemVersion.ps1\n\n\nLa siguiente funci\u00f3n muestra como usar la salida que genera la funci\u00f3n con la versi\u00f3n del sistema operativo para imprimir una cadena de texto. Usamos el cmdlet \nGet-WmiObject\n para obtener una instancia de la clase \nWin32_OperatingSystem\n y acceder a su propiedad \nVersion\n.\n\n\nFunction Get-OperatingSystemVersion\n{\n    (Get-WmiObject -Class Win32_OperatingSystem).Version\n} #end Get-OperatingSystemVersion\n\n\nThis OS is version $(Get-OperatingSystemVersion)\n\n\n\n\n\nFunci\u00f3n con par\u00e1metros: Crear un directorio\n\n\nFuente:\n \nNew-Directory.ps1\n\n\nLa siguiente funci\u00f3n crea un directorio llamado \"MyNewDir\": \n\n\nfunction New-Directory\n{\n    New-Item -ItemType Directory -Name \nMyNewDir\n\n} #end New-Directory\n\nNew-Directory\n\n\n\n\nSi realmente quisieramos que su funcionalidad fuese m\u00e1s gen\u00e9rica cobra sentido poder pasarle el nombre del directorio que queremos crear para crear directorios diferentes, los par\u00e1metros permiten definir variables que alteran el comportamiento de la funci\u00f3n pasandole valores desde su llamada.\n\n\nfunction New-Directory-Ext($dirName)\n{\n    New-Item -ItemType Directory -Name $dirName\n} #end New-Directory-Ext\n\nNew-Directory-Ext \nMyDir1\n\nNew-Directory-Ext \nMyDir2\n\n\n\n\n\nPar\u00e1metros con tipo\n\n\nFuente:\n \nGet-Sum.ps1\n\n\nPodemos restringir el tipo de dato que acepta una par\u00e1metro de una funci\u00f3n, si por ejemplo queremos recibir dos enteros como par\u00e1metros para realizar una suma usamos \n[int]\n:\n\n\nfunction Get-Sum([int] $n1,[int] $n2)\n{\n    $n1+$n2\n} #end Get-Sum\n\n\nSuma de n\u00fameros: $(Get-Sum 3 5)\n\n\n# Esta llamada producir\u00eda un error \n# \nSuma de n\u00fameros:\n+ $(Get-Sum \nTres\n 5)\n\n\n\n\nOtros tipos usados de forma com\u00fan son \n[String]\n, \n[double]\n o \n[DateTime]\n.\n\n\nRetornar datos de una funci\u00f3n\n\n\nComo hemos visto m\u00e1s arriba para retornar datos de la funci\u00f3n simplemente podemos escribir los datos de salida. \n\n\nFuente:\n \nGet-SysDate.ps1\n\n\nfunction Get-SysDate {\n    Get-Date\n} #end Get-SysDate\n\n$tomorrow = (Get-SysDate).AddDays(1)\n$tomorrow\n\n\n\n\nEl cmdlet \nGet-Date\n genera la salida que capturamos desde donde invoca la funci\u00f3n.\n\n\nSi queremos ser m\u00e1s explicitos sobre el dato retornado PS continua soportando la palabra clave \nreturn\n.\n\n\nFuente:\n \nGet-Average.ps1\n\n\nfunction Get-Average {\nparam([int] $a, [int] $b)\n    return ($a+$b)/2    \n} #end Get-Average\n\n\nMedia de n\u00fameros: $(Get-Average 3 5)\n\n\n\n\n\nValores por defecto para los par\u00e1metros\n\n\nFuente:\n \nGet-Greeting.ps1\n\n\nPodemos definir valores por defecto para los par\u00e1metros, este es un ejemplo muy sencillo.\n\n\nfunction Get-Greeting {\nparam([string] $subject=\nWorld\n)\n    Write-Host  \nHello $subject\n\n} #end Get-Greeting\n\nGet-Greeting \nGet-Greeting \nMundo\n\n\n\n\n\nRetornando una colecci\u00f3n (ArrayList)\n\n\nFuente:\n \nGet-ArrayList.ps1\n\n\nRecursos externos\n\n\n\n\nikerlandajuela.wordpress.com \nPowerShell: Ejemplos b\u00e1sicos\n.\n\n\nGet-WmiObject\n.\n\n\nGet-Date\n.\n\n\nhttps://ss64.com/ps/return.html\n.", 
            "title": "Function"
        }, 
        {
            "location": "/sintaxis/function/#funcion-basica", 
            "text": "Fuente:   Write-HolaMundo.ps1  El siguiente ejemplo ilustra una funci\u00f3n super sencilla, cada vez que invocamos a la funci\u00f3n por su nombre (una funci\u00f3n debe \"llamarse\" para que ejecute sus comandos) ejecuta las l\u00edneas de comandos encerradas entre las llaves  { } .     Function Write-HolaMundo\n{\n     Hola \n     Mundo \n}\n\nWrite-HolaMundo\n# Podemos invocar la funci\u00f3n por su nombre tantas veces queramos.\nWrite-HolaMundo", 
            "title": "Funci\u00f3n b\u00e1sica"
        }, 
        {
            "location": "/sintaxis/function/#funcion-para-obtener-la-version-del-sistema-operativo", 
            "text": "Fuente:   Get-OperatingSystemVersion.ps1  La siguiente funci\u00f3n muestra como usar la salida que genera la funci\u00f3n con la versi\u00f3n del sistema operativo para imprimir una cadena de texto. Usamos el cmdlet  Get-WmiObject  para obtener una instancia de la clase  Win32_OperatingSystem  y acceder a su propiedad  Version .  Function Get-OperatingSystemVersion\n{\n    (Get-WmiObject -Class Win32_OperatingSystem).Version\n} #end Get-OperatingSystemVersion This OS is version $(Get-OperatingSystemVersion)", 
            "title": "Funci\u00f3n para obtener la versi\u00f3n del sistema operativo"
        }, 
        {
            "location": "/sintaxis/function/#funcion-con-parametros-crear-un-directorio", 
            "text": "Fuente:   New-Directory.ps1  La siguiente funci\u00f3n crea un directorio llamado \"MyNewDir\":   function New-Directory\n{\n    New-Item -ItemType Directory -Name  MyNewDir \n} #end New-Directory\n\nNew-Directory  Si realmente quisieramos que su funcionalidad fuese m\u00e1s gen\u00e9rica cobra sentido poder pasarle el nombre del directorio que queremos crear para crear directorios diferentes, los par\u00e1metros permiten definir variables que alteran el comportamiento de la funci\u00f3n pasandole valores desde su llamada.  function New-Directory-Ext($dirName)\n{\n    New-Item -ItemType Directory -Name $dirName\n} #end New-Directory-Ext\n\nNew-Directory-Ext  MyDir1 \nNew-Directory-Ext  MyDir2", 
            "title": "Funci\u00f3n con par\u00e1metros: Crear un directorio"
        }, 
        {
            "location": "/sintaxis/function/#parametros-con-tipo", 
            "text": "Fuente:   Get-Sum.ps1  Podemos restringir el tipo de dato que acepta una par\u00e1metro de una funci\u00f3n, si por ejemplo queremos recibir dos enteros como par\u00e1metros para realizar una suma usamos  [int] :  function Get-Sum([int] $n1,[int] $n2)\n{\n    $n1+$n2\n} #end Get-Sum Suma de n\u00fameros: $(Get-Sum 3 5) \n\n# Esta llamada producir\u00eda un error \n#  Suma de n\u00fameros: + $(Get-Sum  Tres  5)  Otros tipos usados de forma com\u00fan son  [String] ,  [double]  o  [DateTime] .", 
            "title": "Par\u00e1metros con tipo"
        }, 
        {
            "location": "/sintaxis/function/#retornar-datos-de-una-funcion", 
            "text": "Como hemos visto m\u00e1s arriba para retornar datos de la funci\u00f3n simplemente podemos escribir los datos de salida.   Fuente:   Get-SysDate.ps1  function Get-SysDate {\n    Get-Date\n} #end Get-SysDate\n\n$tomorrow = (Get-SysDate).AddDays(1)\n$tomorrow  El cmdlet  Get-Date  genera la salida que capturamos desde donde invoca la funci\u00f3n.  Si queremos ser m\u00e1s explicitos sobre el dato retornado PS continua soportando la palabra clave  return .  Fuente:   Get-Average.ps1  function Get-Average {\nparam([int] $a, [int] $b)\n    return ($a+$b)/2    \n} #end Get-Average Media de n\u00fameros: $(Get-Average 3 5)", 
            "title": "Retornar datos de una funci\u00f3n"
        }, 
        {
            "location": "/sintaxis/function/#valores-por-defecto-para-los-parametros", 
            "text": "Fuente:   Get-Greeting.ps1  Podemos definir valores por defecto para los par\u00e1metros, este es un ejemplo muy sencillo.  function Get-Greeting {\nparam([string] $subject= World )\n    Write-Host   Hello $subject \n} #end Get-Greeting\n\nGet-Greeting \nGet-Greeting  Mundo", 
            "title": "Valores por defecto para los par\u00e1metros"
        }, 
        {
            "location": "/sintaxis/function/#retornando-una-coleccion-arraylist", 
            "text": "Fuente:   Get-ArrayList.ps1", 
            "title": "Retornando una colecci\u00f3n (ArrayList)"
        }, 
        {
            "location": "/sintaxis/function/#recursos-externos", 
            "text": "ikerlandajuela.wordpress.com  PowerShell: Ejemplos b\u00e1sicos .  Get-WmiObject .  Get-Date .  https://ss64.com/ps/return.html .", 
            "title": "Recursos externos"
        }, 
        {
            "location": "/sistema-archivos/directorios/", 
            "text": "Obtener los ficheros de un directorio\n\n\nPara obtener una lista de los archivos de un directorio empleamos el cmdlet \nGet-ChildItem\n. Para obtener un item especifico usamos \nGet-Item\n.\n\n\nFuente:\n \nget_files_dir.ps1\n\n\nPara obtener todos los elementos del directorio actual:\n\n\nGet-ChildItem\n\n\n\n\nPodemos buscar aquellos elementos que cumplan un patr\u00f3n:\n\n\nGet-ChildItem *.ps1\n\n\n\n\nSi queremos buscar de forma recursiva dentro de las subcarpetas tambi\u00e9n\n\n\nGet-ChildItem *.txt -Recurse\n\n\n\n\nEspecificamos la ruta donde queremos buscar y excluimos ciertos elementos\n\n\nGet-ChildItem -Path C:\\Windows -Exclude *.png\n\n\n\n\nSi solo queremos listar los directorios.\n\n\nGet-ChildItem \nC:\\Windows\n | where {$_.Attributes -match'Directory'}\n\n\n\n\nBuscar los ficheros modificados antes de una determinada fecha\n\n\nRecursos externos\n\n\n\n\nGet-ChildItem\n: Gets the items and child items in one or more specified locations.\n\n\nTrabajar con archivos y carpetas\n: Navegar a trav\u00e9s de unidades de Windows PowerShell y manipular los elementos son procesos similares al de manipulaci\u00f3n de archivos y carpetas en unidades de disco f\u00edsico de Windows. Explicaremos c\u00f3mo tratar con tareas espec\u00edficas de manipulaci\u00f3n de archivos y carpetas en esta secci\u00f3n.", 
            "title": "Directorios"
        }, 
        {
            "location": "/sistema-archivos/directorios/#obtener-los-ficheros-de-un-directorio", 
            "text": "Para obtener una lista de los archivos de un directorio empleamos el cmdlet  Get-ChildItem . Para obtener un item especifico usamos  Get-Item .  Fuente:   get_files_dir.ps1  Para obtener todos los elementos del directorio actual:  Get-ChildItem  Podemos buscar aquellos elementos que cumplan un patr\u00f3n:  Get-ChildItem *.ps1  Si queremos buscar de forma recursiva dentro de las subcarpetas tambi\u00e9n  Get-ChildItem *.txt -Recurse  Especificamos la ruta donde queremos buscar y excluimos ciertos elementos  Get-ChildItem -Path C:\\Windows -Exclude *.png  Si solo queremos listar los directorios.  Get-ChildItem  C:\\Windows  | where {$_.Attributes -match'Directory'}", 
            "title": "Obtener los ficheros de un directorio"
        }, 
        {
            "location": "/sistema-archivos/directorios/#buscar-los-ficheros-modificados-antes-de-una-determinada-fecha", 
            "text": "", 
            "title": "Buscar los ficheros modificados antes de una determinada fecha"
        }, 
        {
            "location": "/sistema-archivos/directorios/#recursos-externos", 
            "text": "Get-ChildItem : Gets the items and child items in one or more specified locations.  Trabajar con archivos y carpetas : Navegar a trav\u00e9s de unidades de Windows PowerShell y manipular los elementos son procesos similares al de manipulaci\u00f3n de archivos y carpetas en unidades de disco f\u00edsico de Windows. Explicaremos c\u00f3mo tratar con tareas espec\u00edficas de manipulaci\u00f3n de archivos y carpetas en esta secci\u00f3n.", 
            "title": "Recursos externos"
        }, 
        {
            "location": "/active-directory/instalar-modulo/", 
            "text": "Inicio\n\n\nModulo AD", 
            "title": "Instalaci\u00f3n del modulo"
        }, 
        {
            "location": "/active-directory/instalar-modulo/#inicio", 
            "text": "", 
            "title": "Inicio"
        }, 
        {
            "location": "/active-directory/instalar-modulo/#modulo-ad", 
            "text": "", 
            "title": "Modulo AD"
        }, 
        {
            "location": "/recursos/", 
            "text": "Libros\n\n\n\n\nGitBook \ndevops-collective-inc\n: A US 501(c)(3) nonprofit dedicated to DevOps and automation education.\n\n\nThe Big Book of PowerShell Gotchas\n: PowerShell is full of \"gotchas\" - little things that just get in your way and are hard to figure out on your own. This short book is intended to help you figure them out and avoid them.\n\n\nCreating HTML Reports in PowerShell\n: Create beautiful, colorful, multi-section HTML reports from PowerShell - with very little knowledge of CSS or HTML needed!.    \n\n\n\n\n\n\nhttp://ramblingcookiemonster.github.io/Pages/PowerShellResources/index.html\n.\n\n\n\n\nCmdlets\n\n\n\n\nWindows PowerShell Cookbook\n: The following applies to example files from material published by O\u2019Reilly Media, Inc. \n\n\nCmdlet Samples\n: This section describes sample code that is provided in the Windows PowerShell 2.0 SDK.\n\n\nA Task-Based Guide to Windows PowerShell Cmdlets\n: Cmdlets are the heart-and-soul of Windows PowerShell, Microsoft's latest command shell/scripting language. \n\n\n\n\nWebs", 
            "title": "Recursos"
        }, 
        {
            "location": "/recursos/#libros", 
            "text": "GitBook  devops-collective-inc : A US 501(c)(3) nonprofit dedicated to DevOps and automation education.  The Big Book of PowerShell Gotchas : PowerShell is full of \"gotchas\" - little things that just get in your way and are hard to figure out on your own. This short book is intended to help you figure them out and avoid them.  Creating HTML Reports in PowerShell : Create beautiful, colorful, multi-section HTML reports from PowerShell - with very little knowledge of CSS or HTML needed!.        http://ramblingcookiemonster.github.io/Pages/PowerShellResources/index.html .", 
            "title": "Libros"
        }, 
        {
            "location": "/recursos/#cmdlets", 
            "text": "Windows PowerShell Cookbook : The following applies to example files from material published by O\u2019Reilly Media, Inc.   Cmdlet Samples : This section describes sample code that is provided in the Windows PowerShell 2.0 SDK.  A Task-Based Guide to Windows PowerShell Cmdlets : Cmdlets are the heart-and-soul of Windows PowerShell, Microsoft's latest command shell/scripting language.", 
            "title": "Cmdlets"
        }, 
        {
            "location": "/recursos/#webs", 
            "text": "", 
            "title": "Webs"
        }
    ]
}