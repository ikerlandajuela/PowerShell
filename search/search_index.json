{
    "docs": [
        {
            "location": "/", 
            "text": "Web dedicada al scripting en PS (PowerShell) en MS Win, especialmente en servidores con Active Directory y Exchange.\n\n\nLos ejercicios estan probados en una computadora con MS Win7 y PowerShell v2.0.\n\n\nPS\n $PSVersionTable.PSVersion\nPS\n $PSVersionTable\n\n\n\n\nContacto:\n\n\n\n\nTwitter \n@ikernaix\n #PSFabrik.\n\n\nCorreo electr\u00f3nico: ikernaix@gmail.com.", 
            "title": "Inicio"
        }, 
        {
            "location": "/sintaxis/variables/", 
            "text": "Introducci\u00f3n\n\n\nUna de las grandezas de \nPowerShell\n es que guarda la informaci\u00f3n en su tipo nativo: Los \nobjetos\n. PowerShell emplea los \nobject\n del framework .NET. \n\n\nUn objeto basicamente representa una entidad con datos (tambi\u00e9n llamados atributos o propiedades) y unos m\u00e9todos (firmas o funciones) que expone para operar con estos datos. Es una forma de encapsular informaci\u00f3n. Por ahora es suficiente con saber esto, m\u00e1s adelante se explorar\u00e1 m\u00e1s en profundidad los objetos de PS (un objeto es el resultado de la instanciaci\u00f3n de una clase).\n\n\nLos nombres de variables en PS siempre van precedidad del car\u00e1cter '$', por ejemplo una variable que contendra una cadena de texto con el nombre de un usuario podriamos definirla como \n$UserName\n.  \n\n\nFuente:\n \nBasicVarsTypes.ps1\n\n\nLos valores se asignan a una variable usando el operador '=', siguiendo el ejemplo anterior:\n\n\n# Variables de tipo string (cadena de texto) y int (entero)\n$UserName = \nBob\n\n$UserAge = 43\n\n\n\n\nSi queremos establecer el mismo valor a varias variables\n\n\n$a = $b = $c = 1\n\n\n\n\nSi queremos hacerlo con diferentes valores en una l\u00ednea\n\n\n$a, $b, $c = 1, 2, 3\n\n\n\n\nPS soporta infinidad de tipos de datos: cadenas de texto (string), car\u00e1cteres individuales (char), bytes, n\u00fameros enteros (int), booleanos (bool $True/$False)...\n\n\nPara determinar el tipo de una variable podemos usar \n\n\n$b.GetType().Name\n\n\n\n\nLista de los tipos m\u00e1s comunes:\n\n\n\n\n\n\n\n\nTipo dato\n\n\nDescripci\u00f3n\n\n\n\n\n\n\n\n\n\n\n[Array]\n\n\nColecci\u00f3n de elementos\n\n\n\n\n\n\n[Bool]\n\n\nVerdadero ($true) o falso ($false)\n\n\n\n\n\n\n[DateTime]\n\n\nFecha - hora\n\n\n\n\n\n\n[Guid]\n\n\nIdentificador \u00fanico global de 32-bytes\n\n\n\n\n\n\n[HashTable]\n\n\nColecci\u00f3n de pares clave - valores\n\n\n\n\n\n\n[Int32], [Int]\n\n\nEntero de 32 bits\n\n\n\n\n\n\n[PsObject]\n\n\nPowerShell object\n\n\n\n\n\n\n[Regex]\n\n\nExpresi\u00f3n regular\n\n\n\n\n\n\n[ScriptBlock]\n\n\n\n\n\n\n\n\n[Single], [Float]\n\n\nN\u00famero flotante con decimales\n\n\n\n\n\n\n[String]\n\n\nCadena de texto\n\n\n\n\n\n\n[Switch]\n\n\nPowerShell switch parameter\n\n\n\n\n\n\n[TimeSpan]\n\n\nIntervalo de tiempo\n\n\n\n\n\n\n[XmlDocument]\n\n\nDocumento XML\n\n\n\n\n\n\n\n\nLos booleanos se evaluan como una condici\u00f3n binaria de verdadero ($true) o falso ($false).\n\n\n# PS define las variables $true y $false para los booleanos\n$isChecked = $false\nif (!$isChecked) { \nNo\n }\n\n\n\n\nComo comprobar variables\n\n\nhttps://mcpmag.com/articles/2015/12/14/test-variables-in-powershell.aspx\n\n\nEnteros\n\n\nFuente:\n \nIntVars.ps1\n\n\nCon las variables de tipo num\u00e9ricas podemos realizar las operaciones matem\u00e1ticas est\u00e1ndar como: +, -, *, /. \n\n\n$segundosPorDia = 24 * 60 * 60\n$semanasPorAnio = 365 / 7\n\n\n\n\nTambi\u00e9n existen operadores ++ y -- que incrementan o decrementan en una unidad\n\n\n$myNum = 1\n$myNum = $myNum + 1\n# es equivalente a \n$myNum++\n\n\n\n\nSi queremos operar sobre el mismo n\u00famero podemos sintetizar la expresi\u00f3n:\n\n\n# Equivalente a  $myNum = $myNum*2 \n$myNum*=2 \n\n$myNum+=2 \n\n\n\n\nDateTime\n\n\n[DateTime]$Date = \nFebruary 28, 2015\n \n$Today = Get-Date \n$Days = ($Today - $Date).Days \nWrite-Host \nThe hacker encrypted all your servers $Days day(s) ago.\n\n\n\n\n\nEnlaces externos\n\n\n\n\nClase Object (System) - MSDN - Microsoft\n.\n\n\nPowerShell Basics: Introduction to Objects - Windows IT Pro\n.\n\n\nPowerShell Basics: Custom Objects | IT Pro\n.\n\n\nPowerShell objects: A tutorial | Computerworld\n.\n\n\nhttp://www.tomsitpro.com/articles/powershell-variables,2-797.html\n.\n\n\nPowershell Data Types - PowerShell - SS64.com\n.\n\n\nThe PowerShell variable \u2013 Naming, value, data type \u2013 4sysops\n.\n\n\nDisplay and search all variables of a PowerShell script with Get-Variable\n.\n\n\nPowerShell variable properties: Description, Visibility, Options, Attributes\n.", 
            "title": "Variables"
        }, 
        {
            "location": "/sintaxis/variables/#introduccion", 
            "text": "Una de las grandezas de  PowerShell  es que guarda la informaci\u00f3n en su tipo nativo: Los  objetos . PowerShell emplea los  object  del framework .NET.   Un objeto basicamente representa una entidad con datos (tambi\u00e9n llamados atributos o propiedades) y unos m\u00e9todos (firmas o funciones) que expone para operar con estos datos. Es una forma de encapsular informaci\u00f3n. Por ahora es suficiente con saber esto, m\u00e1s adelante se explorar\u00e1 m\u00e1s en profundidad los objetos de PS (un objeto es el resultado de la instanciaci\u00f3n de una clase).  Los nombres de variables en PS siempre van precedidad del car\u00e1cter '$', por ejemplo una variable que contendra una cadena de texto con el nombre de un usuario podriamos definirla como  $UserName .    Fuente:   BasicVarsTypes.ps1  Los valores se asignan a una variable usando el operador '=', siguiendo el ejemplo anterior:  # Variables de tipo string (cadena de texto) y int (entero)\n$UserName =  Bob \n$UserAge = 43  Si queremos establecer el mismo valor a varias variables  $a = $b = $c = 1  Si queremos hacerlo con diferentes valores en una l\u00ednea  $a, $b, $c = 1, 2, 3  PS soporta infinidad de tipos de datos: cadenas de texto (string), car\u00e1cteres individuales (char), bytes, n\u00fameros enteros (int), booleanos (bool $True/$False)...  Para determinar el tipo de una variable podemos usar   $b.GetType().Name  Lista de los tipos m\u00e1s comunes:     Tipo dato  Descripci\u00f3n      [Array]  Colecci\u00f3n de elementos    [Bool]  Verdadero ($true) o falso ($false)    [DateTime]  Fecha - hora    [Guid]  Identificador \u00fanico global de 32-bytes    [HashTable]  Colecci\u00f3n de pares clave - valores    [Int32], [Int]  Entero de 32 bits    [PsObject]  PowerShell object    [Regex]  Expresi\u00f3n regular    [ScriptBlock]     [Single], [Float]  N\u00famero flotante con decimales    [String]  Cadena de texto    [Switch]  PowerShell switch parameter    [TimeSpan]  Intervalo de tiempo    [XmlDocument]  Documento XML     Los booleanos se evaluan como una condici\u00f3n binaria de verdadero ($true) o falso ($false).  # PS define las variables $true y $false para los booleanos\n$isChecked = $false\nif (!$isChecked) {  No  }", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/sintaxis/variables/#como-comprobar-variables", 
            "text": "https://mcpmag.com/articles/2015/12/14/test-variables-in-powershell.aspx", 
            "title": "Como comprobar variables"
        }, 
        {
            "location": "/sintaxis/variables/#enteros", 
            "text": "Fuente:   IntVars.ps1  Con las variables de tipo num\u00e9ricas podemos realizar las operaciones matem\u00e1ticas est\u00e1ndar como: +, -, *, /.   $segundosPorDia = 24 * 60 * 60\n$semanasPorAnio = 365 / 7  Tambi\u00e9n existen operadores ++ y -- que incrementan o decrementan en una unidad  $myNum = 1\n$myNum = $myNum + 1\n# es equivalente a \n$myNum++  Si queremos operar sobre el mismo n\u00famero podemos sintetizar la expresi\u00f3n:  # Equivalente a  $myNum = $myNum*2 \n$myNum*=2 \n\n$myNum+=2", 
            "title": "Enteros"
        }, 
        {
            "location": "/sintaxis/variables/#datetime", 
            "text": "[DateTime]$Date =  February 28, 2015  \n$Today = Get-Date \n$Days = ($Today - $Date).Days \nWrite-Host  The hacker encrypted all your servers $Days day(s) ago.", 
            "title": "DateTime"
        }, 
        {
            "location": "/sintaxis/variables/#enlaces-externos", 
            "text": "Clase Object (System) - MSDN - Microsoft .  PowerShell Basics: Introduction to Objects - Windows IT Pro .  PowerShell Basics: Custom Objects | IT Pro .  PowerShell objects: A tutorial | Computerworld .  http://www.tomsitpro.com/articles/powershell-variables,2-797.html .  Powershell Data Types - PowerShell - SS64.com .  The PowerShell variable \u2013 Naming, value, data type \u2013 4sysops .  Display and search all variables of a PowerShell script with Get-Variable .  PowerShell variable properties: Description, Visibility, Options, Attributes .", 
            "title": "Enlaces externos"
        }, 
        {
            "location": "/sintaxis/objetos/", 
            "text": "Una de las grandezas de \nPowerShell\n es que guarda la informaci\u00f3n en su tipo nativo: Los objetos. \n\n\n$myVar = 2\n$myVar\n\n$myVar++\n# NO funciona\n#$myVar**\n$myVar\n\n$myVar+=2\n#$myVar = $myVar + 2\n$myVar\n\n$myVar*=2\n#$myVar = $myVar * 2\n$myVar", 
            "title": "Objetos"
        }, 
        {
            "location": "/sintaxis/if/", 
            "text": "Introducci\u00f3n\n\n\nSi queremos evaluar una condici\u00f3n bajo la cual se ejecute una porci\u00f3n de c\u00f3digo usamos las sentencias condicionales \nif\n, \nelseif\n, y \nelse\n.\n\n\nEste ejemplo es muy sencillo, podr\u00eda ser usado perfectamente para condicionar la ejecuci\u00f3n del unos comandos a una determinada fecha o hora.\n\n\nFuente:\n \nIfDate.ps1\n\n\n$Calendar = Get-Date\nIf ($Calendar.Month -eq '5') {\nEste mes es Mayo\n}\nElse {\nNo es Mayo\n}\n\n\n\n\nEn este ejemplo vamos evaluando condiciones de forma encadenada comprobando si la variable \n$temperature\n se ajusta a un determinado l\u00edmite. Empleamos el operador de comparaci\u00f3n \n-le\n (\nComparison operators - PowerShell - SS64.com\n) que comprueba si la variable es menor o igual que un entero (less or equal). \n\n\nFuente:\n \nIfTemperature.ps1\n\n\n$temperature = 90\nif($temperature -le 0)\n{\n    \nBalmy Canadian Summer\n\n}\nelseif($temperature -le 32)\n{\n    \nFreezing\n\n}\nelseif($temperature -le 50)\n{\n    \nCold\n\n}\nelseif($temperature -le 70)\n{\n    \nWarm\n\n}\nelse\n{\n    \nHot\n\n}\n\n\n\n\nAsignaci\u00f3n de variables con If\n\n\nFuente:\n \nIfVarAssignment.ps1\n\n\nAdicionalmente podemos usar las expresiones condicionales para asignar el valor a una variable.\n\n\n$result = if(Get-Process -Name notepad) { \nRunning\n } else { \nNot running\n }\n\n\n\n\nOperadores de comparaci\u00f3n\n\n\nFuente:\n \nComparisonOperatorsExamples.ps1\n\n\n\n\n\n\n\n\nOperador\n\n\nDescripci\u00f3n\n\n\n\n\n\n\n\n\n\n\n-eq\n\n\nEqual\n\n\n\n\n\n\n-ne\n\n\nNot equal\n\n\n\n\n\n\n-ge\n\n\nGreater than or equal\n\n\n\n\n\n\n-gt\n\n\nGreater than\n\n\n\n\n\n\n-lt\n\n\nLess than\n\n\n\n\n\n\n-le\n\n\nLess than or equal\n\n\n\n\n\n\n-like\n\n\nWildcard comparison\n\n\n\n\n\n\n-notlike\n\n\nWildcard comparison\n\n\n\n\n\n\n-match\n\n\nRegular expression comparison\n\n\n\n\n\n\n-notmatch\n\n\nRegular expression comparison\n\n\n\n\n\n\n-replace\n\n\nReplace operator\n\n\n\n\n\n\n-contains\n\n\nContainment operator\n\n\n\n\n\n\n-notcontains\n\n\nContainment operator\n\n\n\n\n\n\n-in\n\n\nLike \u2013contains, but with the operands reversed.(PowerShell 3.0)\n\n\n\n\n\n\n-notin\n\n\nLike \u2013notcontains, but with the operands reversed.(PowerShell 3.0)\n\n\n\n\n\n\n\n\nOperadores l\u00f3gicos\n\n\n\n\n\n\n\n\nOperador\n\n\nDescripci\u00f3n\n\n\n\n\n\n\n\n\n\n\n-and\n\n\nLogical And\n\n\n\n\n\n\n-or\n\n\nLogical Or\n\n\n\n\n\n\n-xor\n\n\nLogical exclusive Or\n\n\n\n\n\n\n-not\n\n\nlogical not\n\n\n\n\n\n\n!\n\n\nlogical not\n\n\n\n\n\n\n\n\n$demo = $null\nif (-Not ($demo)) { write \nZero, null or Empty\n}\nif (!($demo)) { write \nZero, null or Empty\n}\n\n\n\n\n# PowerShell If AND Statement Simple Example\nClear-Host\n$Calendar = Get-Date\nIf ($Calendar.Day -eq '25' -And $Calendar.Month -eq '12') \n{\n    \nChristmas Day\n\n}\nElse \n{\n    \nIt's not Christmas yet! \n + $Calendar.Month +\n/\n +$Calendar.Day \n}\n\n\n\n\nOperadores ternarios\n\n\n#$CarColor = 'Red'\n$CarColor = 'Blue' \n$MatchColor = @{$true = 'The car color is blue'; $false = 'The car color is not blue'}[$CarColor -eq 'Blue']\n$MatchColor\n\n\n\n\nEnlaces externos\n\n\n\n\nAn Introduction to Error Handling in PowerShell \u2013 Keith Babinec's ...\n.\n\n\nPowerShell Hacks: Ternarys and Null-coalescing operators\n.\n\n\nA Simpler If/Then Conditional Logic in PowerShell\n.\n\n\nComparison Operators in PowerShell - TechNet Articles - United ...\n.", 
            "title": "If"
        }, 
        {
            "location": "/sintaxis/if/#introduccion", 
            "text": "Si queremos evaluar una condici\u00f3n bajo la cual se ejecute una porci\u00f3n de c\u00f3digo usamos las sentencias condicionales  if ,  elseif , y  else .  Este ejemplo es muy sencillo, podr\u00eda ser usado perfectamente para condicionar la ejecuci\u00f3n del unos comandos a una determinada fecha o hora.  Fuente:   IfDate.ps1  $Calendar = Get-Date\nIf ($Calendar.Month -eq '5') { Este mes es Mayo }\nElse { No es Mayo }  En este ejemplo vamos evaluando condiciones de forma encadenada comprobando si la variable  $temperature  se ajusta a un determinado l\u00edmite. Empleamos el operador de comparaci\u00f3n  -le  ( Comparison operators - PowerShell - SS64.com ) que comprueba si la variable es menor o igual que un entero (less or equal).   Fuente:   IfTemperature.ps1  $temperature = 90\nif($temperature -le 0)\n{\n     Balmy Canadian Summer \n}\nelseif($temperature -le 32)\n{\n     Freezing \n}\nelseif($temperature -le 50)\n{\n     Cold \n}\nelseif($temperature -le 70)\n{\n     Warm \n}\nelse\n{\n     Hot \n}", 
            "title": "Introducci\u00f3n"
        }, 
        {
            "location": "/sintaxis/if/#asignacion-de-variables-con-if", 
            "text": "Fuente:   IfVarAssignment.ps1  Adicionalmente podemos usar las expresiones condicionales para asignar el valor a una variable.  $result = if(Get-Process -Name notepad) {  Running  } else {  Not running  }", 
            "title": "Asignaci\u00f3n de variables con If"
        }, 
        {
            "location": "/sintaxis/if/#operadores-de-comparacion", 
            "text": "Fuente:   ComparisonOperatorsExamples.ps1     Operador  Descripci\u00f3n      -eq  Equal    -ne  Not equal    -ge  Greater than or equal    -gt  Greater than    -lt  Less than    -le  Less than or equal    -like  Wildcard comparison    -notlike  Wildcard comparison    -match  Regular expression comparison    -notmatch  Regular expression comparison    -replace  Replace operator    -contains  Containment operator    -notcontains  Containment operator    -in  Like \u2013contains, but with the operands reversed.(PowerShell 3.0)    -notin  Like \u2013notcontains, but with the operands reversed.(PowerShell 3.0)", 
            "title": "Operadores de comparaci\u00f3n"
        }, 
        {
            "location": "/sintaxis/if/#operadores-logicos", 
            "text": "Operador  Descripci\u00f3n      -and  Logical And    -or  Logical Or    -xor  Logical exclusive Or    -not  logical not    !  logical not     $demo = $null\nif (-Not ($demo)) { write  Zero, null or Empty }\nif (!($demo)) { write  Zero, null or Empty }  # PowerShell If AND Statement Simple Example\nClear-Host\n$Calendar = Get-Date\nIf ($Calendar.Day -eq '25' -And $Calendar.Month -eq '12') \n{\n     Christmas Day \n}\nElse \n{\n     It's not Christmas yet!   + $Calendar.Month + /  +$Calendar.Day \n}", 
            "title": "Operadores l\u00f3gicos"
        }, 
        {
            "location": "/sintaxis/if/#operadores-ternarios", 
            "text": "#$CarColor = 'Red'\n$CarColor = 'Blue' \n$MatchColor = @{$true = 'The car color is blue'; $false = 'The car color is not blue'}[$CarColor -eq 'Blue']\n$MatchColor", 
            "title": "Operadores ternarios"
        }, 
        {
            "location": "/sintaxis/if/#enlaces-externos", 
            "text": "An Introduction to Error Handling in PowerShell \u2013 Keith Babinec's ... .  PowerShell Hacks: Ternarys and Null-coalescing operators .  A Simpler If/Then Conditional Logic in PowerShell .  Comparison Operators in PowerShell - TechNet Articles - United ... .", 
            "title": "Enlaces externos"
        }, 
        {
            "location": "/sintaxis/array/", 
            "text": "Un array contiene una lista de elementos de datos. Una diferencia frente a otros lenguajes de programaci\u00f3n es que los elementos del array no tienen porque ser del mismo tipo a no ser que se defina el tipo de datos que alberga de forma explicita (\nstrongly typed\n).\n\n\nCreando un array\n\n\nFuente:\n \narray.ps1\n\n\nPara crear un array definimos cada elemento separado por \n,\n.\n\n\n$myArray = 1,\nHola\n,3.5,\nMundo\n\n$myArray    \n\n\n\n\nO usando la sintaxis explicita:\n\n\n$myArray = @(1,\nHola\n,3.5,\nMundo\n)\n\n\n\n\nPodemos el valor de un elemento determinado por su posici\u00f3n \n$myArray[1]\n contiene la cadena \"Hola\" (\nla primera posici\u00f3n de un array es la 0\n).\n\n\nPara distribuir los elementos en variables individuales:\n\n\n$var1,$var2,$var3 = $myArray\n\n\n\n\nCon un array de enteros (int) podemos usar el operador de rango para crear una secuencia de n\u00fameros ordenada\n\n\n$myArray = 1,2,3,4,5,6,7\n$myArray = (1..7)\n\n\n\n\nPara obtener el n\u00famero de elementos usamos el miembro del objeto array length: \n$myArray.length\n. \n\n\nTambi\u00e9n podemos crear arrays multidimensionales, por ejemplo un array de 2x3:\n\n\n$myMultiArray = @(\n    (1,2,3),\n    (40,50,60)\n)\n\n\n\n\nA\u00f1adir valores a un array\n\n\nPara a\u00f1adir nuevos valores al array** usamos el operador \n+=\n.\n\n\n$myArray += 12\n$countries += 'Hola'\n\n\n\n\nObtener elementos de un array\n\n\n$myArray\n: Retorna todos los elementos del array, arriba ya hemos visto como acceder a elementos individuales por su posici\u00f3n.\n\n\nPara obtener un rango de elementos usamos por ejemplo \n$myArray[4..6]\n para obtener los valores comprendidos entre la posici\u00f3n 4 y la 6.\n\n\nPara \n\n\nArrays Asociativos o Hashtable\n\n\n$myHashtable = @{ Key1 = \nValue1\n; \nKey 2\n = 1,2,3 }\n\n\n\n\nArrays de objetos\n\n\nFuente:\n \narray_objects.ps1\n\n\nCuando se crea un array sin especificar el tipo de datos que alberga PS crea el array como un array de objetos. Nosotros tambi\u00e9n podemos crear un array de objetos usando el cmdlet \nNew-Object\n.\n\n\n# Creamos un array de objetos de tipo string\n$myArray = New-Object string[] 10\n$myArray[5] = \nHola\n \n# Permite hacer esto\n$myArray[1] = 12\n\n$myArray\n\n$myArray.gettype()\n\n\n\n\nFuente:\n \narray_obj_strong_typed.ps1\n\n\nSi queremos crear un array cuyo tipo de dato base sea inmutable podemos usar la siguiente sintaxis:\n\n\n$myList = New-Object Collections.Generic.List[Int]\n$myList.Add(10)\n# Esto produce error\n$myList.Add(\nHola\n)\n\n\n\n\nFuente:\n \narray_get_process.ps1\n\n\nPara almacenar la salida de un comando que genera una lista (\nGet-Process\n) usamos la una asignaci\u00f3n a una varible, el siguiente ejemplo muestra todos los procesos corriendo un nuestro ordenador.\n\n\n$myArray = Get-Process\n$myArray\n\n\n\n\nArray de objetos creados a medida\n\n\nFuente:\n \narray_custom_obj.ps1\n\n\nPowerShell a pesar de ser un lenguaje interpretado demuestra ser muy avanzando ya que permite crear objetos a medida y jugar con ellos en un array.\n\n\n# Creamos un objeto propio\n$myObject = New-Object System.Object\n\n# A\u00f1adimos nuestras propiedades al objeto\n$myObject | Add-Member -type NoteProperty -name Name -Value \nIker_PC\n\n$myObject | Add-Member -type NoteProperty -name Manufacturer -Value \nDell\n\n$myObject | Add-Member -type NoteProperty -name ProcessorSpeed -Value \n3 Ghz\n\n$myObject | Add-Member -type NoteProperty -name Memory -Value \n6 GB\n\n\n$myObject\n\n\nMemory is: \n+$myObject.Memory\n\nif ( (Test-Connection $myObject.Name -quiet) -eq $false)\n{\n    $myObject.Name + \n ICMP echo request error\n\n}\nelse \n{\n    $myObject.Name + \n ICMP echo request ok\n\n}\n\n# Modificamos una propiedad de un objeto\n$myObject.Manufacturer = \nHP\n\n$myObject\n\n\n\n\nAhora creamos un nuevo objeto y a\u00f1adimos ambos a un array:\n\n\n# Creamos un array vacio\n$myArray = @()\n$myArray += $myObject\n\n#Definimos un nuevo objeto\n$myObject2 = New-Object System.Object\n$myObject2 | Add-Member -type NoteProperty -name Name -Value \nAsier_PC\n\n$myObject2 | Add-Member -type NoteProperty -name Manufacturer -Value \nAcer\n\n$myObject2 | Add-Member -type NoteProperty -name ProcessorSpeed -Value \n3 Ghz\n\n$myObject2 | Add-Member -type NoteProperty -name Memory -Value \n4 GB\n\n\n$myArray += $myObject2\n\n$myArray | Select-Object name\n\n\n\n\nFuente:\n \narray_custom_obj_alt.ps1\n\n\nPodemos crear objetos a medida creando las propiedades como un array para el objeto de tipo PSObject.\n\n\nRecursos arrays\n\n\n\n\nhttps://ss64.com/ps/syntax-arrays.html\n\n\nGet-Blog : Ryan\u2019s PowerShell Blog \nCreating an Array of Custom Objects in Powershell\n.\n\n\nNew-Object\n.\n\n\nWindows PowerShell Cookbook by Lee Holmes\n.\n\n\nUsing the Get-Process Cmdlet\n.\n\n\nGet-Process\n.\n\n\nTest-Connection\n: Sends ICMP echo request packets (\"pings\") to one or more computers.\n\n\nPowershell: Array of Custom Objects (PSCustomObject/PSObject)\n.\n\n\nPSObject Class\n.", 
            "title": "Arrays"
        }, 
        {
            "location": "/sintaxis/array/#creando-un-array", 
            "text": "Fuente:   array.ps1  Para crear un array definimos cada elemento separado por  , .  $myArray = 1, Hola ,3.5, Mundo \n$myArray      O usando la sintaxis explicita:  $myArray = @(1, Hola ,3.5, Mundo )  Podemos el valor de un elemento determinado por su posici\u00f3n  $myArray[1]  contiene la cadena \"Hola\" ( la primera posici\u00f3n de un array es la 0 ).  Para distribuir los elementos en variables individuales:  $var1,$var2,$var3 = $myArray  Con un array de enteros (int) podemos usar el operador de rango para crear una secuencia de n\u00fameros ordenada  $myArray = 1,2,3,4,5,6,7\n$myArray = (1..7)  Para obtener el n\u00famero de elementos usamos el miembro del objeto array length:  $myArray.length .   Tambi\u00e9n podemos crear arrays multidimensionales, por ejemplo un array de 2x3:  $myMultiArray = @(\n    (1,2,3),\n    (40,50,60)\n)", 
            "title": "Creando un array"
        }, 
        {
            "location": "/sintaxis/array/#anadir-valores-a-un-array", 
            "text": "Para a\u00f1adir nuevos valores al array** usamos el operador  += .  $myArray += 12\n$countries += 'Hola'", 
            "title": "A\u00f1adir valores a un array"
        }, 
        {
            "location": "/sintaxis/array/#obtener-elementos-de-un-array", 
            "text": "$myArray : Retorna todos los elementos del array, arriba ya hemos visto como acceder a elementos individuales por su posici\u00f3n.  Para obtener un rango de elementos usamos por ejemplo  $myArray[4..6]  para obtener los valores comprendidos entre la posici\u00f3n 4 y la 6.  Para", 
            "title": "Obtener elementos de un array"
        }, 
        {
            "location": "/sintaxis/array/#arrays-asociativos-o-hashtable", 
            "text": "$myHashtable = @{ Key1 =  Value1 ;  Key 2  = 1,2,3 }", 
            "title": "Arrays Asociativos o Hashtable"
        }, 
        {
            "location": "/sintaxis/array/#arrays-de-objetos", 
            "text": "Fuente:   array_objects.ps1  Cuando se crea un array sin especificar el tipo de datos que alberga PS crea el array como un array de objetos. Nosotros tambi\u00e9n podemos crear un array de objetos usando el cmdlet  New-Object .  # Creamos un array de objetos de tipo string\n$myArray = New-Object string[] 10\n$myArray[5] =  Hola  \n# Permite hacer esto\n$myArray[1] = 12\n\n$myArray\n\n$myArray.gettype()  Fuente:   array_obj_strong_typed.ps1  Si queremos crear un array cuyo tipo de dato base sea inmutable podemos usar la siguiente sintaxis:  $myList = New-Object Collections.Generic.List[Int]\n$myList.Add(10)\n# Esto produce error\n$myList.Add( Hola )  Fuente:   array_get_process.ps1  Para almacenar la salida de un comando que genera una lista ( Get-Process ) usamos la una asignaci\u00f3n a una varible, el siguiente ejemplo muestra todos los procesos corriendo un nuestro ordenador.  $myArray = Get-Process\n$myArray", 
            "title": "Arrays de objetos"
        }, 
        {
            "location": "/sintaxis/array/#array-de-objetos-creados-a-medida", 
            "text": "Fuente:   array_custom_obj.ps1  PowerShell a pesar de ser un lenguaje interpretado demuestra ser muy avanzando ya que permite crear objetos a medida y jugar con ellos en un array.  # Creamos un objeto propio\n$myObject = New-Object System.Object\n\n# A\u00f1adimos nuestras propiedades al objeto\n$myObject | Add-Member -type NoteProperty -name Name -Value  Iker_PC \n$myObject | Add-Member -type NoteProperty -name Manufacturer -Value  Dell \n$myObject | Add-Member -type NoteProperty -name ProcessorSpeed -Value  3 Ghz \n$myObject | Add-Member -type NoteProperty -name Memory -Value  6 GB \n\n$myObject Memory is:  +$myObject.Memory\n\nif ( (Test-Connection $myObject.Name -quiet) -eq $false)\n{\n    $myObject.Name +   ICMP echo request error \n}\nelse \n{\n    $myObject.Name +   ICMP echo request ok \n}\n\n# Modificamos una propiedad de un objeto\n$myObject.Manufacturer =  HP \n$myObject  Ahora creamos un nuevo objeto y a\u00f1adimos ambos a un array:  # Creamos un array vacio\n$myArray = @()\n$myArray += $myObject\n\n#Definimos un nuevo objeto\n$myObject2 = New-Object System.Object\n$myObject2 | Add-Member -type NoteProperty -name Name -Value  Asier_PC \n$myObject2 | Add-Member -type NoteProperty -name Manufacturer -Value  Acer \n$myObject2 | Add-Member -type NoteProperty -name ProcessorSpeed -Value  3 Ghz \n$myObject2 | Add-Member -type NoteProperty -name Memory -Value  4 GB \n\n$myArray += $myObject2\n\n$myArray | Select-Object name  Fuente:   array_custom_obj_alt.ps1  Podemos crear objetos a medida creando las propiedades como un array para el objeto de tipo PSObject.", 
            "title": "Array de objetos creados a medida"
        }, 
        {
            "location": "/sintaxis/array/#recursos-arrays", 
            "text": "https://ss64.com/ps/syntax-arrays.html  Get-Blog : Ryan\u2019s PowerShell Blog  Creating an Array of Custom Objects in Powershell .  New-Object .  Windows PowerShell Cookbook by Lee Holmes .  Using the Get-Process Cmdlet .  Get-Process .  Test-Connection : Sends ICMP echo request packets (\"pings\") to one or more computers.  Powershell: Array of Custom Objects (PSCustomObject/PSObject) .  PSObject Class .", 
            "title": "Recursos arrays"
        }, 
        {
            "location": "/sintaxis/for/", 
            "text": "Los bucles \nfor\n ejecutan un bloque de comandos n veces bas\u00e1ndose en una condici\u00f3n de parada.\n\n\nSintaxis:\n\n\nfor (init; condition; repeat) \n{\n    # command_block\n    # ...\n}\n\n\n\n\ninit\n se usa normalmente para inicializar una variable a un valor para usarla dentro del bucle como contador de iteraciones, \ncondition\n suele tener la condici\u00f3n de parada del bucle y \nrepeat\n contiene comandos, normalmente cuando se usa como contador contendr\u00e1 como se incrementa la variable inicializada en \ninit\n como en este primer ejemplo. \n\n\nFor b\u00e1sico\n\n\nFuente:\n \narray.ps1\n\n\nLa variable \n$i\n se inicializa con el valor 1, mientr\u00e1s \n$i\n sea menor o igual que 10 (ver \ncomparison operators\n su valor se incrementar\u00e1 y ejecutar\u00e1 el bloque de comandos entre llaves. \n\n\nPS\n for($i=1; $i -le 10; $i++){$i} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\nBucle For con Arrays\n\n\nFuente:\n \nfor_array.ps1\n\n\nProbablemente tiene m\u00e1s sentido recorrer un array usando \nForEach\n pero es muy com\u00fan hacerlo tambi\u00e9n con contador para recorrer cada elemento del array conociendo su longitud:\n\n\n$myarray = @(\ntest1\n, \ntest2\n, \ntest3\n)\nfor ($i=0; $i -lt $myarray.length; $i++) \n{\n    $myarray[$i]\n}\n\n\n\n\nAlgo m\u00e1s avanzando es hacerlo con una tuber\u00eda (\npipe\n).\n\n\n$myarray |foreach { $_ }\n\n\n\n\nRecursos\n\n\n\n\nhttps://ss64.com/ps/for.html\n.\n\n\n[comparison operators](https://ss64.com/ps/syntax-compare.html.", 
            "title": "For"
        }, 
        {
            "location": "/sintaxis/for/#for-basico", 
            "text": "Fuente:   array.ps1  La variable  $i  se inicializa con el valor 1, mientr\u00e1s  $i  sea menor o igual que 10 (ver  comparison operators  su valor se incrementar\u00e1 y ejecutar\u00e1 el bloque de comandos entre llaves.   PS  for($i=1; $i -le 10; $i++){$i} \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10", 
            "title": "For b\u00e1sico"
        }, 
        {
            "location": "/sintaxis/for/#bucle-for-con-arrays", 
            "text": "Fuente:   for_array.ps1  Probablemente tiene m\u00e1s sentido recorrer un array usando  ForEach  pero es muy com\u00fan hacerlo tambi\u00e9n con contador para recorrer cada elemento del array conociendo su longitud:  $myarray = @( test1 ,  test2 ,  test3 )\nfor ($i=0; $i -lt $myarray.length; $i++) \n{\n    $myarray[$i]\n}  Algo m\u00e1s avanzando es hacerlo con una tuber\u00eda ( pipe ).  $myarray |foreach { $_ }", 
            "title": "Bucle For con Arrays"
        }, 
        {
            "location": "/sintaxis/for/#recursos", 
            "text": "https://ss64.com/ps/for.html .  [comparison operators](https://ss64.com/ps/syntax-compare.html.", 
            "title": "Recursos"
        }, 
        {
            "location": "/sintaxis/foreach/", 
            "text": "ForEach\n permite crear bucles que ejecutan una serie de rutinas de forma iterativa.\n\n\nSintaxis:\n\n\nForEach (item In collection) {ScriptBlock}\n\n\n\n\nRecorre una colecci\u00f3n de elementos y en cada iteraci\u00f3n nos proporciona el siguiente elemento (item) de la colecci\u00f3n (collection).\n\n\nForEach con arrays\n\n\nforeach_array.ps1\n\n\nDeclaramos tres variables que contienen n\u00fameros enteros:\n\n\n$a = 1 \n$b = 2\n$c = 3\n\n\n\n\nCon las tres variables componemos un array:\n\n\n$d = $a,$b,$c\n\n\n\n\nEn el caso de arrays de enteros podemos usar el operador de rango para crear una secuencia ordenada de n\u00fameros, para el ejemplo superior hubiese sido equivalente crearlo as\u00ed:\n\n\n$d = 1..3\n\n\n\n\nPodemos acceder a cada elemento del array \n\n\nEnlaces", 
            "title": "Foreach"
        }, 
        {
            "location": "/sintaxis/foreach/#foreach-con-arrays", 
            "text": "foreach_array.ps1  Declaramos tres variables que contienen n\u00fameros enteros:  $a = 1 \n$b = 2\n$c = 3  Con las tres variables componemos un array:  $d = $a,$b,$c  En el caso de arrays de enteros podemos usar el operador de rango para crear una secuencia ordenada de n\u00fameros, para el ejemplo superior hubiese sido equivalente crearlo as\u00ed:  $d = 1..3  Podemos acceder a cada elemento del array", 
            "title": "ForEach con arrays"
        }, 
        {
            "location": "/sintaxis/foreach/#enlaces", 
            "text": "", 
            "title": "Enlaces"
        }, 
        {
            "location": "/sintaxis/function/", 
            "text": "Las funciones permiten agrupar comandos con un prop\u00f3sito y ejecutarlo desde cualquier parte de nuestro programa invoc\u00e1ndola por su nombre, evitamos repetir los mismos comandos una y otra vez cuando queremos repetir una operaci\u00f3n. Encapsulando la l\u00f3gica de la aplicaci\u00f3n en una funci\u00f3n adem\u00e1s fomenta la reutilizaci\u00f3n del c\u00f3digo en otros scripts y la legibilidad para entender su funcionamiento.\n\n\nPara crear una funci\u00f3n comenzamos con la palabra clave \nFunction\n para declararla seguida del nombre de la funci\u00f3n que queramos darle, como \nbuena pr\u00e1ctica\n los manuales recomiendan usar una combinaci\u00f3n de verbo-nombre, podemos incluso obtener una lista est\u00e1ndar de verbos que usa PS.  \n\n\nGet-Command -CommandType cmdlet | Group-Object -Property Verb | Sort-Object -Property count -Descending\n\n\n\n\nFunci\u00f3n b\u00e1sica\n\n\nFuente:\n \nWrite-HolaMundo.ps1\n\n\nEl siguiente ejemplo ilustra una funci\u00f3n super sencilla, cada vez que invocamos a la funci\u00f3n por su nombre (una funci\u00f3n debe \"llamarse\" para que ejecute sus comandos) ejecuta las l\u00edneas de comandos encerradas entre las llaves \n{ }\n.   \n\n\nFunction Write-HolaMundo\n{\n    \nHola\n\n    \nMundo\n\n}\n\nWrite-HolaMundo\n# Podemos invocar la funci\u00f3n por su nombre tantas veces queramos.\nWrite-HolaMundo\n\n\n\n\nFunci\u00f3n para obtener la versi\u00f3n del sistema operativo\n\n\nFuente:\n \nGet-OperatingSystemVersion.ps1\n\n\nLa siguiente funci\u00f3n muestra como usar la salida que genera la funci\u00f3n con la versi\u00f3n del sistema operativo para imprimir una cadena de texto. Usamos el cmdlet \nGet-WmiObject\n para obtener una instancia de la clase \nWin32_OperatingSystem\n y acceder a su propiedad \nVersion\n.\n\n\nFunction Get-OperatingSystemVersion\n{\n    (Get-WmiObject -Class Win32_OperatingSystem).Version\n} #end Get-OperatingSystemVersion\n\n\nThis OS is version $(Get-OperatingSystemVersion)\n\n\n\n\n\nFunci\u00f3n con par\u00e1metros: Crear un directorio\n\n\nFuente:\n \nNew-Directory.ps1\n\n\nLa siguiente funci\u00f3n crea un directorio llamado \"MyNewDir\": \n\n\nfunction New-Directory\n{\n    New-Item -ItemType Directory -Name \nMyNewDir\n\n} #end New-Directory\n\nNew-Directory\n\n\n\n\nSi realmente quisieramos que su funcionalidad fuese m\u00e1s gen\u00e9rica cobra sentido poder pasarle el nombre del directorio que queremos crear para crear directorios diferentes, los par\u00e1metros permiten definir variables que alteran el comportamiento de la funci\u00f3n pasandole valores desde su llamada.\n\n\nfunction New-Directory-Ext($dirName)\n{\n    New-Item -ItemType Directory -Name $dirName\n} #end New-Directory-Ext\n\nNew-Directory-Ext \nMyDir1\n\nNew-Directory-Ext \nMyDir2\n\n\n\n\n\nPar\u00e1metros con tipo\n\n\nFuente:\n \nGet-Sum.ps1\n\n\nPodemos restringir el tipo de dato que acepta una par\u00e1metro de una funci\u00f3n, si por ejemplo queremos recibir dos enteros como par\u00e1metros para realizar una suma usamos \n[int]\n:\n\n\nfunction Get-Sum([int] $n1,[int] $n2)\n{\n    $n1+$n2\n} #end Get-Sum\n\n\nSuma de n\u00fameros: $(Get-Sum 3 5)\n\n\n# Esta llamada producir\u00eda un error \n# \nSuma de n\u00fameros:\n+ $(Get-Sum \nTres\n 5)\n\n\n\n\nOtros tipos usados de forma com\u00fan son \n[String]\n, \n[double]\n o \n[DateTime]\n.\n\n\nRetornar datos de una funci\u00f3n\n\n\nComo hemos visto m\u00e1s arriba para retornar datos de la funci\u00f3n simplemente podemos escribir los datos de salida. \n\n\nFuente:\n \nGet-SysDate.ps1\n\n\nfunction Get-SysDate {\n    Get-Date\n} #end Get-SysDate\n\n$tomorrow = (Get-SysDate).AddDays(1)\n$tomorrow\n\n\n\n\nEl cmdlet \nGet-Date\n genera la salida que capturamos desde donde invoca la funci\u00f3n.\n\n\nSi queremos ser m\u00e1s explicitos sobre el dato retornado PS continua soportando la palabra clave \nreturn\n.\n\n\nFuente:\n \nGet-Average.ps1\n\n\nfunction Get-Average {\nparam([int] $a, [int] $b)\n    return ($a+$b)/2    \n} #end Get-Average\n\n\nMedia de n\u00fameros: $(Get-Average 3 5)\n\n\n\n\n\nValores por defecto para los par\u00e1metros\n\n\nFuente:\n \nGet-Greeting.ps1\n\n\nPodemos definir valores por defecto para los par\u00e1metros, este es un ejemplo muy sencillo.\n\n\nfunction Get-Greeting {\nparam([string] $subject=\nWorld\n)\n    Write-Host  \nHello $subject\n\n} #end Get-Greeting\n\nGet-Greeting \nGet-Greeting \nMundo\n\n\n\n\n\nRetornando una colecci\u00f3n (ArrayList)\n\n\nFuente:\n \nGet-ArrayList.ps1\n\n\nRecursos externos\n\n\n\n\nikerlandajuela.wordpress.com \nPowerShell: Ejemplos b\u00e1sicos\n.\n\n\nGet-WmiObject\n.\n\n\nGet-Date\n.\n\n\nhttps://ss64.com/ps/return.html\n.", 
            "title": "Function"
        }, 
        {
            "location": "/sintaxis/function/#funcion-basica", 
            "text": "Fuente:   Write-HolaMundo.ps1  El siguiente ejemplo ilustra una funci\u00f3n super sencilla, cada vez que invocamos a la funci\u00f3n por su nombre (una funci\u00f3n debe \"llamarse\" para que ejecute sus comandos) ejecuta las l\u00edneas de comandos encerradas entre las llaves  { } .     Function Write-HolaMundo\n{\n     Hola \n     Mundo \n}\n\nWrite-HolaMundo\n# Podemos invocar la funci\u00f3n por su nombre tantas veces queramos.\nWrite-HolaMundo", 
            "title": "Funci\u00f3n b\u00e1sica"
        }, 
        {
            "location": "/sintaxis/function/#funcion-para-obtener-la-version-del-sistema-operativo", 
            "text": "Fuente:   Get-OperatingSystemVersion.ps1  La siguiente funci\u00f3n muestra como usar la salida que genera la funci\u00f3n con la versi\u00f3n del sistema operativo para imprimir una cadena de texto. Usamos el cmdlet  Get-WmiObject  para obtener una instancia de la clase  Win32_OperatingSystem  y acceder a su propiedad  Version .  Function Get-OperatingSystemVersion\n{\n    (Get-WmiObject -Class Win32_OperatingSystem).Version\n} #end Get-OperatingSystemVersion This OS is version $(Get-OperatingSystemVersion)", 
            "title": "Funci\u00f3n para obtener la versi\u00f3n del sistema operativo"
        }, 
        {
            "location": "/sintaxis/function/#funcion-con-parametros-crear-un-directorio", 
            "text": "Fuente:   New-Directory.ps1  La siguiente funci\u00f3n crea un directorio llamado \"MyNewDir\":   function New-Directory\n{\n    New-Item -ItemType Directory -Name  MyNewDir \n} #end New-Directory\n\nNew-Directory  Si realmente quisieramos que su funcionalidad fuese m\u00e1s gen\u00e9rica cobra sentido poder pasarle el nombre del directorio que queremos crear para crear directorios diferentes, los par\u00e1metros permiten definir variables que alteran el comportamiento de la funci\u00f3n pasandole valores desde su llamada.  function New-Directory-Ext($dirName)\n{\n    New-Item -ItemType Directory -Name $dirName\n} #end New-Directory-Ext\n\nNew-Directory-Ext  MyDir1 \nNew-Directory-Ext  MyDir2", 
            "title": "Funci\u00f3n con par\u00e1metros: Crear un directorio"
        }, 
        {
            "location": "/sintaxis/function/#parametros-con-tipo", 
            "text": "Fuente:   Get-Sum.ps1  Podemos restringir el tipo de dato que acepta una par\u00e1metro de una funci\u00f3n, si por ejemplo queremos recibir dos enteros como par\u00e1metros para realizar una suma usamos  [int] :  function Get-Sum([int] $n1,[int] $n2)\n{\n    $n1+$n2\n} #end Get-Sum Suma de n\u00fameros: $(Get-Sum 3 5) \n\n# Esta llamada producir\u00eda un error \n#  Suma de n\u00fameros: + $(Get-Sum  Tres  5)  Otros tipos usados de forma com\u00fan son  [String] ,  [double]  o  [DateTime] .", 
            "title": "Par\u00e1metros con tipo"
        }, 
        {
            "location": "/sintaxis/function/#retornar-datos-de-una-funcion", 
            "text": "Como hemos visto m\u00e1s arriba para retornar datos de la funci\u00f3n simplemente podemos escribir los datos de salida.   Fuente:   Get-SysDate.ps1  function Get-SysDate {\n    Get-Date\n} #end Get-SysDate\n\n$tomorrow = (Get-SysDate).AddDays(1)\n$tomorrow  El cmdlet  Get-Date  genera la salida que capturamos desde donde invoca la funci\u00f3n.  Si queremos ser m\u00e1s explicitos sobre el dato retornado PS continua soportando la palabra clave  return .  Fuente:   Get-Average.ps1  function Get-Average {\nparam([int] $a, [int] $b)\n    return ($a+$b)/2    \n} #end Get-Average Media de n\u00fameros: $(Get-Average 3 5)", 
            "title": "Retornar datos de una funci\u00f3n"
        }, 
        {
            "location": "/sintaxis/function/#valores-por-defecto-para-los-parametros", 
            "text": "Fuente:   Get-Greeting.ps1  Podemos definir valores por defecto para los par\u00e1metros, este es un ejemplo muy sencillo.  function Get-Greeting {\nparam([string] $subject= World )\n    Write-Host   Hello $subject \n} #end Get-Greeting\n\nGet-Greeting \nGet-Greeting  Mundo", 
            "title": "Valores por defecto para los par\u00e1metros"
        }, 
        {
            "location": "/sintaxis/function/#retornando-una-coleccion-arraylist", 
            "text": "Fuente:   Get-ArrayList.ps1", 
            "title": "Retornando una colecci\u00f3n (ArrayList)"
        }, 
        {
            "location": "/sintaxis/function/#recursos-externos", 
            "text": "ikerlandajuela.wordpress.com  PowerShell: Ejemplos b\u00e1sicos .  Get-WmiObject .  Get-Date .  https://ss64.com/ps/return.html .", 
            "title": "Recursos externos"
        }, 
        {
            "location": "/sintaxis/select/", 
            "text": "PowerShell destaca por el uso de los objetos de datos y como se pueden transmitir estos incluso usando tuber\u00edas (pipe) de un comando a otro. El cmdlet Select-Object como su nombre indica selecciona objetos. \n\n\nSeleccionando el n\u00famero de objetos\n\n\nUsamos el par\u00e1metro \n-First\n para seleccionar X objetos desde el principio o \n-Last\n para hacerlo desde el final.\n\n\nPor ejemplo \n\n\nGet-EventLog -List | Select -First 1 | Get-Member\n\n\n\n\nEnlaces externos\n\n\n\n\nPowerShell Basics: Select-Object | IT Pro\n.", 
            "title": "Select"
        }, 
        {
            "location": "/sintaxis/select/#seleccionando-el-numero-de-objetos", 
            "text": "Usamos el par\u00e1metro  -First  para seleccionar X objetos desde el principio o  -Last  para hacerlo desde el final.  Por ejemplo   Get-EventLog -List | Select -First 1 | Get-Member", 
            "title": "Seleccionando el n\u00famero de objetos"
        }, 
        {
            "location": "/sintaxis/select/#enlaces-externos", 
            "text": "PowerShell Basics: Select-Object | IT Pro .", 
            "title": "Enlaces externos"
        }, 
        {
            "location": "/sistema-archivos/directorios/", 
            "text": "Obtener los ficheros de un directorio\n\n\nPara obtener una lista de los archivos de un directorio empleamos el cmdlet \nGet-ChildItem\n. Para obtener un item especifico usamos \nGet-Item\n.\n\n\nFuente:\n \nget_files_dir.ps1\n\n\nPara obtener todos los elementos del directorio actual:\n\n\nGet-ChildItem\n\n\n\n\nPodemos buscar aquellos elementos que cumplan un patr\u00f3n:\n\n\nGet-ChildItem *.ps1\n\n\n\n\nSi queremos buscar de forma recursiva dentro de las subcarpetas tambi\u00e9n\n\n\nGet-ChildItem *.txt -Recurse\n\n\n\n\nEspecificamos la ruta donde queremos buscar y excluimos ciertos elementos\n\n\nGet-ChildItem -Path C:\\Windows -Exclude *.png\n\n\n\n\nSi solo queremos listar los directorios.\n\n\nGet-ChildItem \nC:\\Windows\n | where {$_.Attributes -match'Directory'}\n\n\n\n\nBuscar los ficheros modificados antes de una determinada fecha\n\n\nRecursos externos\n\n\n\n\nGet-ChildItem\n: Gets the items and child items in one or more specified locations.\n\n\nTrabajar con archivos y carpetas\n: Navegar a trav\u00e9s de unidades de Windows PowerShell y manipular los elementos son procesos similares al de manipulaci\u00f3n de archivos y carpetas en unidades de disco f\u00edsico de Windows. Explicaremos c\u00f3mo tratar con tareas espec\u00edficas de manipulaci\u00f3n de archivos y carpetas en esta secci\u00f3n.", 
            "title": "Directorios"
        }, 
        {
            "location": "/sistema-archivos/directorios/#obtener-los-ficheros-de-un-directorio", 
            "text": "Para obtener una lista de los archivos de un directorio empleamos el cmdlet  Get-ChildItem . Para obtener un item especifico usamos  Get-Item .  Fuente:   get_files_dir.ps1  Para obtener todos los elementos del directorio actual:  Get-ChildItem  Podemos buscar aquellos elementos que cumplan un patr\u00f3n:  Get-ChildItem *.ps1  Si queremos buscar de forma recursiva dentro de las subcarpetas tambi\u00e9n  Get-ChildItem *.txt -Recurse  Especificamos la ruta donde queremos buscar y excluimos ciertos elementos  Get-ChildItem -Path C:\\Windows -Exclude *.png  Si solo queremos listar los directorios.  Get-ChildItem  C:\\Windows  | where {$_.Attributes -match'Directory'}", 
            "title": "Obtener los ficheros de un directorio"
        }, 
        {
            "location": "/sistema-archivos/directorios/#buscar-los-ficheros-modificados-antes-de-una-determinada-fecha", 
            "text": "", 
            "title": "Buscar los ficheros modificados antes de una determinada fecha"
        }, 
        {
            "location": "/sistema-archivos/directorios/#recursos-externos", 
            "text": "Get-ChildItem : Gets the items and child items in one or more specified locations.  Trabajar con archivos y carpetas : Navegar a trav\u00e9s de unidades de Windows PowerShell y manipular los elementos son procesos similares al de manipulaci\u00f3n de archivos y carpetas en unidades de disco f\u00edsico de Windows. Explicaremos c\u00f3mo tratar con tareas espec\u00edficas de manipulaci\u00f3n de archivos y carpetas en esta secci\u00f3n.", 
            "title": "Recursos externos"
        }, 
        {
            "location": "/admin/event-log/", 
            "text": "Los logs de eventos son el pilar de la monitorizaci\u00f3n de sistemas Win. Para trabajar con los logs PS proporciona dos llamadas, los cmdlets \nGet-EventLog\n y \nGet-WinEvent\n.\n\n\nListado de todos los logs de eventos", 
            "title": "Event Logs"
        }, 
        {
            "location": "/admin/event-log/#listado-de-todos-los-logs-de-eventos", 
            "text": "", 
            "title": "Listado de todos los logs de eventos"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/", 
            "text": "Visualizar las propiedades de una cuenta\n\n\nFuente:\n \nGet-ADUser-basics.ps1\n\n\nEl cmdlet \nGet-ADUser\n permite obtener los datos de uno o mas usuarios de AD (Active-Directory).\n\n\nEste es el ejemplo m\u00e1s sencillo, \nla siguiente consulta obtiene s\u00f3lo algunas de la propiedades de la cuenta\n, buscamos una cuenta de un empleado ficticio llamado Bob Sinclair:\n\n\nGet-ADUser -Identity 'b.sinclair'\n# Podemos hacer lo mismo filtrando por la propiedad Name\nGet-ADUser -Filter 'Name -like \nBob Sinclair\n'\n\n\n\n\nPara ver que propiedades podemos consultar de un objeto usuario es siempre \u00fatil tener enlaces como estos a mano:\n\n\n\n\nActive Directory: Get-ADUser Default and Extended Properties ...\n.\n\n\nUser Object Attributes (Windows) - MSDN - Microsoft\n.\n\n\n\n\nPropiedades adicionales\n\n\nSi queremos visualizar propiedades que no se muestran por defecto, por ejemplo la oficina de trabajo y la descripci\u00f3n de la cuenta:\n\n\nGet-ADUser -Identity 'b.sinclair' -Properties Description,Office\n# Para ver TODAS las propiedades de forma paginada\nGet-ADUser -Identity 'b.sinclair' -Properties * | more \nGet-ADUser -Identity 'b.sinclair' -Properties msDS-UserPasswordExpiryTimeComputed, PasswordLastSet, CannotChangePassword, PasswordExpired\n\n\n\n\nModificar las propiedades de un usuarios\n\n\nSet-ADUser permite modificar un usuario AD (advertencia: La cuenta de Manager debe existir en AD)\n\n\nSet-ADUser -Identity 'b.sinclair' -Office 'London'\nGet-ADUser -Identity 'b.sinclair' -Properties Office\n\nSet-ADUser -Identity 'b.sinclair' -Manager 'i.landajuela'\n# Otra forma de hacerlo usando un pipe\n# Get-ADUser -Identity 'b.sinclair' | Set-ADUser -Manager 'i.landajuela'\nGet-ADUser -Identity 'b.sinclair' -Properties Manager\n\n# Para comprobar si la clave a expirado\nGet-ADUser -Identity 'b.sinclair' -Properties PasswordExpired\n\n\n\n\nEjemplos avanzados\n\n\nFuente:\n \nFilter-Users.ps1\n\n\nLas fecha de caducidad de la clave y la fecha cuando se estableci\u00f3 la clave por \u00faltima vez siempre son valores interesantes para los admins. Si queremos realizar varias operaciones sobre una lista de usuarios primero lo almacenamos en una lista de objetos.\n\n\nEl siguiente comando filtra las cuentas de usuarios habilitadas y que sus claves expiren.  \n\n\n$Users = Get-ADUser -filter {Enabled -eq $True -and PasswordNeverExpires -eq $False} -Properties msDS-UserPasswordExpiryTimeComputed, PasswordLastSet, CannotChangePassword\n\n\n\n\nSi solo queremos mostrar una lista de usuarios junto a fecha de expiraci\u00f3n de la clave y la \u00faltima vez que se modifico la clave:\n\n\n$Users | select Name, @{Name=\nExpiryDate\n;Expression={[datetime]::FromFileTime($_.\nmsDS-UserPasswordExpiryTimeComputed\n)}}, PasswordLastSet\n\n\n\n\nComo el atributo \nUserPasswordExpiryTimeComputed\n no se almacena de forma legible para humanos usamos la funci\u00f3n \nFromFileTime\n. \n\n\nSeguridad de cuentas de usuarios\n\n\nFuente:\n \nUsers-SecOp.ps1\n.\n\n\nAlgunas operaciones b\u00e1sicas de seguridad para administrar usuarios:\n\n\n# Deshabilitar una cuenta \nDisable-ADAccount -Identity 'b.sinclair' \n\n# Habilitar una cuenta \nEnable-ADAccount -Identity 'b.sinclair' \n\n# Desbloquear una cuenta de usuario\nUnlock-ADAccount -Identity 'b.sinclair' \n\n# Cambiar la clave \nSet-ADAccountPassword -Identity b.sinclair -Reset -NewPassword (ConvertTo-SecureString -AsPlainText \np@ssw0rd\n -Force)\n\n\n\n\nCrear una cuenta AD y Exchange para un usuario\n\n\nFuente:\n \nNew-UserAccount.ps1\n\n\nVamos a crear un usuario de AD y su buz\u00f3n de correo en Exchange, para poder ejecutar el script deben estar cargados los m\u00f3dulos AD y Exhange.\n\n\nEmpezamos el script comprobando previamente si existe el buz\u00f3n, es importante saber tambi\u00e9n que cuando borramos el buz\u00f3n se elimina tambi\u00e9n el objeto de usuario de AD.\n\n\n$Mailboxes = Get-Mailbox -Identity 'b.sinclair' | measure-object\nif ( $Mailboxes.Count -gt 0 ) \n{\n        Remove-Mailbox -Identity 'b.sinclair'\n}\n\n\n\n\nPodemos hacer una comprobaci\u00f3n similar para una cuenta AD.\n\n\n$Users =  Get-ADUser -Identity 'b.sinclair' | measure-object\nif ( $Users.Count -gt 0 ) \n{       \n    Remove-ADUser -Identity 'b.sinclair'\n}\n\n\n\n\nDespu\u00e9s de esas comprobaciones vamos al caso concreto, para crear el usuario en AD vamos a usar tres cmdlets: \nNew-ADUser\n, \nSet-ADUser\n,\nAdd-ADGroupMember\n. El \u00faltimo comando no es imprescindible, nos permite incorporar la cuenta a un grupo.\n\n\nVamos a definir los par\u00e1metros a pasar al comando \nNew-ADUser\n en un array. Definimos en variables simples los valores de los campos, por ejemplo:\n\n\n$PlainPassword = \nClaveInicial\n\n$SecurePassword = $PlainPassword | ConvertTo-SecureString -AsPlainText -Force\n\n$MyName = \nBob\n\n$MySurname = \nSinclair\n\n$MySamAccountName = \nb.sinclair\n\n\n\n\n\nAhora s\u00ed creamos el array:\n\n\n$parms = @{ \n        Name = $MyName + \n \n + $MySurname\n        GivenName = $MyName\n        Surname = $MySurname\n        SamAccountName = $MySamAccountName \n        }\n\n\n\n\nY creamos el usuario:\n\n\nNew-ADUser @parms\nSet-ADUser -Identity $MySamAccountName -ChangePasswordAtLogon $False\nAdd-ADGroupMember -Identity \nEscritorio Remoto\n -Member $MySamAccountName\n\n\n\n\nAhora ya podemos crear la cuenta de correo en Exchange:\n\n\nEnable-Mailbox -Identity $MyEmailAddress -Database \nMailbox Database 12\n \nEnable-Mailbox -Identity $MyEmailAddress -Archive\n\n\n\n\nRecursos externos\n\n\n\n\nGet-ADUser - TechNet - Microsoft\n.\n\n\nSet-ADUser - TechNet - Microsoft\n.\n\n\nPowerShell: Get-ADUser to retrieve password last set and expiry information\n.\n\n\nObtaining the password expiry date with PowerShell \u2013 4sysops\n.\n\n\nSelect-Object - PowerShell - SS64.com\n.\n\n\nActive Directory: Get-ADUser Default and Extended Properties ...\n.\n\n\nHabilitar o deshabilitar un buz\u00f3n de archivo en Exchange Online ...\n.", 
            "title": "Cuentas usuarios"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#visualizar-las-propiedades-de-una-cuenta", 
            "text": "Fuente:   Get-ADUser-basics.ps1  El cmdlet  Get-ADUser  permite obtener los datos de uno o mas usuarios de AD (Active-Directory).  Este es el ejemplo m\u00e1s sencillo,  la siguiente consulta obtiene s\u00f3lo algunas de la propiedades de la cuenta , buscamos una cuenta de un empleado ficticio llamado Bob Sinclair:  Get-ADUser -Identity 'b.sinclair'\n# Podemos hacer lo mismo filtrando por la propiedad Name\nGet-ADUser -Filter 'Name -like  Bob Sinclair '  Para ver que propiedades podemos consultar de un objeto usuario es siempre \u00fatil tener enlaces como estos a mano:   Active Directory: Get-ADUser Default and Extended Properties ... .  User Object Attributes (Windows) - MSDN - Microsoft .", 
            "title": "Visualizar las propiedades de una cuenta"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#propiedades-adicionales", 
            "text": "Si queremos visualizar propiedades que no se muestran por defecto, por ejemplo la oficina de trabajo y la descripci\u00f3n de la cuenta:  Get-ADUser -Identity 'b.sinclair' -Properties Description,Office\n# Para ver TODAS las propiedades de forma paginada\nGet-ADUser -Identity 'b.sinclair' -Properties * | more \nGet-ADUser -Identity 'b.sinclair' -Properties msDS-UserPasswordExpiryTimeComputed, PasswordLastSet, CannotChangePassword, PasswordExpired", 
            "title": "Propiedades adicionales"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#modificar-las-propiedades-de-un-usuarios", 
            "text": "Set-ADUser permite modificar un usuario AD (advertencia: La cuenta de Manager debe existir en AD)  Set-ADUser -Identity 'b.sinclair' -Office 'London'\nGet-ADUser -Identity 'b.sinclair' -Properties Office\n\nSet-ADUser -Identity 'b.sinclair' -Manager 'i.landajuela'\n# Otra forma de hacerlo usando un pipe\n# Get-ADUser -Identity 'b.sinclair' | Set-ADUser -Manager 'i.landajuela'\nGet-ADUser -Identity 'b.sinclair' -Properties Manager\n\n# Para comprobar si la clave a expirado\nGet-ADUser -Identity 'b.sinclair' -Properties PasswordExpired", 
            "title": "Modificar las propiedades de un usuarios"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#ejemplos-avanzados", 
            "text": "Fuente:   Filter-Users.ps1  Las fecha de caducidad de la clave y la fecha cuando se estableci\u00f3 la clave por \u00faltima vez siempre son valores interesantes para los admins. Si queremos realizar varias operaciones sobre una lista de usuarios primero lo almacenamos en una lista de objetos.  El siguiente comando filtra las cuentas de usuarios habilitadas y que sus claves expiren.    $Users = Get-ADUser -filter {Enabled -eq $True -and PasswordNeverExpires -eq $False} -Properties msDS-UserPasswordExpiryTimeComputed, PasswordLastSet, CannotChangePassword  Si solo queremos mostrar una lista de usuarios junto a fecha de expiraci\u00f3n de la clave y la \u00faltima vez que se modifico la clave:  $Users | select Name, @{Name= ExpiryDate ;Expression={[datetime]::FromFileTime($_. msDS-UserPasswordExpiryTimeComputed )}}, PasswordLastSet  Como el atributo  UserPasswordExpiryTimeComputed  no se almacena de forma legible para humanos usamos la funci\u00f3n  FromFileTime .", 
            "title": "Ejemplos avanzados"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#seguridad-de-cuentas-de-usuarios", 
            "text": "Fuente:   Users-SecOp.ps1 .  Algunas operaciones b\u00e1sicas de seguridad para administrar usuarios:  # Deshabilitar una cuenta \nDisable-ADAccount -Identity 'b.sinclair' \n\n# Habilitar una cuenta \nEnable-ADAccount -Identity 'b.sinclair' \n\n# Desbloquear una cuenta de usuario\nUnlock-ADAccount -Identity 'b.sinclair' \n\n# Cambiar la clave \nSet-ADAccountPassword -Identity b.sinclair -Reset -NewPassword (ConvertTo-SecureString -AsPlainText  p@ssw0rd  -Force)", 
            "title": "Seguridad de cuentas de usuarios"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#crear-una-cuenta-ad-y-exchange-para-un-usuario", 
            "text": "Fuente:   New-UserAccount.ps1  Vamos a crear un usuario de AD y su buz\u00f3n de correo en Exchange, para poder ejecutar el script deben estar cargados los m\u00f3dulos AD y Exhange.  Empezamos el script comprobando previamente si existe el buz\u00f3n, es importante saber tambi\u00e9n que cuando borramos el buz\u00f3n se elimina tambi\u00e9n el objeto de usuario de AD.  $Mailboxes = Get-Mailbox -Identity 'b.sinclair' | measure-object\nif ( $Mailboxes.Count -gt 0 ) \n{\n        Remove-Mailbox -Identity 'b.sinclair'\n}  Podemos hacer una comprobaci\u00f3n similar para una cuenta AD.  $Users =  Get-ADUser -Identity 'b.sinclair' | measure-object\nif ( $Users.Count -gt 0 ) \n{       \n    Remove-ADUser -Identity 'b.sinclair'\n}  Despu\u00e9s de esas comprobaciones vamos al caso concreto, para crear el usuario en AD vamos a usar tres cmdlets:  New-ADUser ,  Set-ADUser , Add-ADGroupMember . El \u00faltimo comando no es imprescindible, nos permite incorporar la cuenta a un grupo.  Vamos a definir los par\u00e1metros a pasar al comando  New-ADUser  en un array. Definimos en variables simples los valores de los campos, por ejemplo:  $PlainPassword =  ClaveInicial \n$SecurePassword = $PlainPassword | ConvertTo-SecureString -AsPlainText -Force\n\n$MyName =  Bob \n$MySurname =  Sinclair \n$MySamAccountName =  b.sinclair   Ahora s\u00ed creamos el array:  $parms = @{ \n        Name = $MyName +     + $MySurname\n        GivenName = $MyName\n        Surname = $MySurname\n        SamAccountName = $MySamAccountName \n        }  Y creamos el usuario:  New-ADUser @parms\nSet-ADUser -Identity $MySamAccountName -ChangePasswordAtLogon $False\nAdd-ADGroupMember -Identity  Escritorio Remoto  -Member $MySamAccountName  Ahora ya podemos crear la cuenta de correo en Exchange:  Enable-Mailbox -Identity $MyEmailAddress -Database  Mailbox Database 12  \nEnable-Mailbox -Identity $MyEmailAddress -Archive", 
            "title": "Crear una cuenta AD y Exchange para un usuario"
        }, 
        {
            "location": "/active-directory/cuentas-usuarios/#recursos-externos", 
            "text": "Get-ADUser - TechNet - Microsoft .  Set-ADUser - TechNet - Microsoft .  PowerShell: Get-ADUser to retrieve password last set and expiry information .  Obtaining the password expiry date with PowerShell \u2013 4sysops .  Select-Object - PowerShell - SS64.com .  Active Directory: Get-ADUser Default and Extended Properties ... .  Habilitar o deshabilitar un buz\u00f3n de archivo en Exchange Online ... .", 
            "title": "Recursos externos"
        }, 
        {
            "location": "/active-directory/grupos/", 
            "text": "Usuarios y grupos\n\n\nObtener los nombres de los grupos a los que pertenece un usuario:\n\n\nGet-ADPrincipalGroupMembership 'b.sinclair' | Select name\n\n\n\n\nAlgo similar pero ahora queremos obtener las cuentas que pertecenen a un grupo:\n\n\nGet-ADGroupMember -identity 'Nombre del grupo' -recursive | select name\n\n\n\n\nRemove-ADGroupMember -Identity 'Nombre del grupo' -Member 'b.sinclair'", 
            "title": "Grupos"
        }, 
        {
            "location": "/active-directory/grupos/#usuarios-y-grupos", 
            "text": "Obtener los nombres de los grupos a los que pertenece un usuario:  Get-ADPrincipalGroupMembership 'b.sinclair' | Select name  Algo similar pero ahora queremos obtener las cuentas que pertecenen a un grupo:  Get-ADGroupMember -identity 'Nombre del grupo' -recursive | select name  Remove-ADGroupMember -Identity 'Nombre del grupo' -Member 'b.sinclair'", 
            "title": "Usuarios y grupos"
        }, 
        {
            "location": "/exchange/basico/", 
            "text": "Obtener informaci\u00f3n servidores buzones de correo\n\n\nEl cmdlet \nGet-MailboxServer\n permite obtener informaci\u00f3n sobre los servidores de correo.\n\n\nFuente:\n \nShow-MailBox-Server.ps1\n\n\nGet-MailboxServer\n\n\n\n\nObtener informaci\u00f3n de un buzon\n\n\nFuente:\n \nShow-MailBox-User.ps1\n\n\nPodemos ver si tiene establecida una cuota de correo en la tercera columna.\n\n\nGet-Mailbox -Identity 'b.sinclair'\n\n\n\n\nPero un buz\u00f3n de Exchange Online tiene asociada m\u00e1s informaci\u00f3n, adem\u00e1s de las cuatro propiedades devueltas por el cmdlet Get-Mailbox.\n\n\nGet-Mailbox -Identity 'b.sinclair' | Select-Object *\n# Tambi\u00e9n puede usar el cmdlet Select-Object para especificar un conjunto de valores de propiedad que se van a mostrar.\nGet-Mailbox -Identity 'b.sinclair' | Select-Object DisplayName, LitigationHoldEnabled, LitigationHoldDate, LitigationHoldOwner, LitigationHoldDuration\n\n\n\n\nBases de datos Mailbox\n\n\nPara obtener los nombres de la bases de datos usadas como Mailbox:\n\n\nGet-MailboxDatabase\n# Si queremos obtener los buzones de una base de datos concreta\nGet-MailboxDatabase \nMailbox Database 1\n  | Get-Mailbox \n\n\n\n\nTambi\u00e9n podemos obtener estad\u00edsticas e incluso obtener el tama\u00f1op total de cada buzones en una BD.\n\n\nGet-MailboxDatabase \nMailbox Database 1\n | Get-MailboxStatistics | Sort totalitemsize -desc | ft displayname, totalitemsize, itemcount\n\n\n\n\nAlernativamente podemos podemos obtener los datos de un buz\u00f3n de correo espec\u00edfico:\n\n\nGet-MailboxStatistics -identity b.sinclair| fl\n\n\n\n\nEnlaces externos\n\n\n\n\nGet-MailboxServer - TechNet - Microsoft\n.\n\n\nList of active mailboxes (PowerShell) - CodeTwo\n.\n\n\ncunninghamp/Get-MailboxReport.ps1\n.\n\n\nBrowsing Mailbox Databases in Exchange 2007 and 2010\n.\n\n\nGet-MailboxReport.ps1 \u2013 PowerShell Script to Generate Mailbox Reports\n.\n\n\nHow to Calculate Exchange 2010 Mailbox Sizes with PowerShell\n.\n\n\nThe essential guide to PowerShell in Exchange\n.", 
            "title": "B\u00e1sico"
        }, 
        {
            "location": "/exchange/basico/#obtener-informacion-servidores-buzones-de-correo", 
            "text": "El cmdlet  Get-MailboxServer  permite obtener informaci\u00f3n sobre los servidores de correo.  Fuente:   Show-MailBox-Server.ps1  Get-MailboxServer", 
            "title": "Obtener informaci\u00f3n servidores buzones de correo"
        }, 
        {
            "location": "/exchange/basico/#obtener-informacion-de-un-buzon", 
            "text": "Fuente:   Show-MailBox-User.ps1  Podemos ver si tiene establecida una cuota de correo en la tercera columna.  Get-Mailbox -Identity 'b.sinclair'  Pero un buz\u00f3n de Exchange Online tiene asociada m\u00e1s informaci\u00f3n, adem\u00e1s de las cuatro propiedades devueltas por el cmdlet Get-Mailbox.  Get-Mailbox -Identity 'b.sinclair' | Select-Object *\n# Tambi\u00e9n puede usar el cmdlet Select-Object para especificar un conjunto de valores de propiedad que se van a mostrar.\nGet-Mailbox -Identity 'b.sinclair' | Select-Object DisplayName, LitigationHoldEnabled, LitigationHoldDate, LitigationHoldOwner, LitigationHoldDuration", 
            "title": "Obtener informaci\u00f3n de un buzon"
        }, 
        {
            "location": "/exchange/basico/#bases-de-datos-mailbox", 
            "text": "Para obtener los nombres de la bases de datos usadas como Mailbox:  Get-MailboxDatabase\n# Si queremos obtener los buzones de una base de datos concreta\nGet-MailboxDatabase  Mailbox Database 1   | Get-Mailbox   Tambi\u00e9n podemos obtener estad\u00edsticas e incluso obtener el tama\u00f1op total de cada buzones en una BD.  Get-MailboxDatabase  Mailbox Database 1  | Get-MailboxStatistics | Sort totalitemsize -desc | ft displayname, totalitemsize, itemcount  Alernativamente podemos podemos obtener los datos de un buz\u00f3n de correo espec\u00edfico:  Get-MailboxStatistics -identity b.sinclair| fl", 
            "title": "Bases de datos Mailbox"
        }, 
        {
            "location": "/exchange/basico/#enlaces-externos", 
            "text": "Get-MailboxServer - TechNet - Microsoft .  List of active mailboxes (PowerShell) - CodeTwo .  cunninghamp/Get-MailboxReport.ps1 .  Browsing Mailbox Databases in Exchange 2007 and 2010 .  Get-MailboxReport.ps1 \u2013 PowerShell Script to Generate Mailbox Reports .  How to Calculate Exchange 2010 Mailbox Sizes with PowerShell .  The essential guide to PowerShell in Exchange .", 
            "title": "Enlaces externos"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/", 
            "text": "SQLite\n es una base de datos empotrada, no sigue el cl\u00e1sico esquema de cliente servidor sino que el motor de la base de datos se incluye en nuestras aplicaciones, esto lo convierte en altamente portable y ideal para entornos embebidos con limitaciones y caracter\u00edsticas reducidas (podemos copiar y pegar nuestra aplicaci\u00f3n sin necesidad de instalaciones adicionales como el sistema de gesti\u00f3n de bases de datos). Adem\u00e1s el c\u00f3digo fuente es de dominio p\u00fablico y esta apadrinado por \nSQLite Consortium\n entre cuyos miembros se incluyen: Mozilla, Bloomberg y otros. Esto ya es garant\u00eda de solidez y de futuro desarrollo.\n\n\nSQLite almacena toda la BD (Base de Datos) en un s\u00f3lo fichero de disco\n (junto con los \u00edndices, triggers, etc,.).\n\n\nLa librer\u00eda SQLite es muy liviana, en total ocupa menos de 500KiB, como dec\u00eda m\u00e1s arriba ideal para entornos reducidos como Smartphones Android o una PDA.\n\n\nSystem.Data.SQLite ADO.NET\n\n\nSystem.Data.SQLite\n es un proveedor ADO.NET para \nSQLite\n. ADO.NET es un conjunto de clases que exponen servicios de acceso a datos para programadores de .NET Framework.\n\n\nPara instalar el componente SQLite vamos a descargar previamente \nNuget\n CLI (Command Line Interface) para usarlo desde l\u00ednea de comandos sin necesidad de usarlo desde el IDE Visual Studio (\nnuget.exe Windows x86 Commandline v4.4.1\n).\n\n\nFuente:\n \nGet-NuGet-Latest-Cli.ps1\n\n\n$url = \nhttps://dist.nuget.org/win-x86-commandline/latest/nuget.exe\n\n$output = \nnuget.exe\n\n$start_time = Get-Date\n\nImport-Module BitsTransfer\nStart-BitsTransfer -Source $url -Destination $output\nWrite-Output \nTime taken: $((Get-Date).Subtract($start_time).Seconds) second(s)\n\n\n\n\n\nAhora usando NuGet buscamos paquete:\n\n\nPS\n .\\nuget.exe list System.Data.SQLite\n\n\n\n\nE instalamos \n\n\nPS\n .\\nuget.exe install System.Data.SQLite -Version 1.0.106  \n\n\n\n\nNota: Hasta el momento siguiendo este m\u00e9todo no he conseguido cargara la libreria DLL usando \n[System.Reflection.Assembly]::LoadFrom($SQLiteDLLPath)\n \n\n\nRuntime \nx64\n y \n\nx86\n.\n\n\nPSSQLite PowerShell Module\n\n\nPSSQLite (\nGitHub\n) es un m\u00f3dulo de PS para trabajar con bases de datos \nSQLite\n. Est\u00e1 disponible de forma libre en GitHub para su descarga.\n\n\nYo lo he descargado e integrado en mis fuentes con el resto de scripts, tambi\u00e9n lo he descargado comprimido como \nPSSQLite-master.zip\n para mantener intactos los fuentes originales (Usar sino \nInstall-PSSQLite.ps1\n para hacerlo todo con un script).\n\n\nPS\n git clone https://github.com/RamblingCookieMonster/PSSQLite.git\nPS\n Import-Module PSSQLite.psm1\n# Get commands in the module\nPS\n Get-Command -Module PSSQLite\n\n\n\n\nPSSQLite: Creando la BD y una tabla\n\n\nFuente:\n \nPSSQLite_Ex1.ps1\n \n\n\nA continuaci\u00f3n vamos a crear la base de datos en el fichero \n\"Names.SQLite\"\n y una tabla de ejemplo.\n\n\nPara importar el m\u00f3dulo \nPSSQLite\n he usado prestadas unas l\u00edneas de c\u00f3digo que no vienen al caso pero que se puede consultar en el script de ejemplo. \n\n\nPara evitar errores primero compruebo si ya existe la BD con \nTest-Path\n, en ese caso borro el fichero \n\n\n$Database = \n.\\Names.SQLite\n\n# Si ya existe el fichero con la BD previamente lo borramos\nif (Test-Path $Database) {Remove-Item $Database}\n\n$Query = \nCREATE TABLE NAMES (\n    fullname VARCHAR(20) PRIMARY KEY, \n    surname TEXT, \n    givenname TEXT, \n    BirthDate DATETIME)\n\n\n# Create a database and a table\nInvoke-SqliteQuery -Query $Query -DataSource $Database\n\n# Veamos la informaci\u00f3n de la tabla recien creada\nInvoke-SqliteQuery -DataSource $Database -Query \nPRAGMA table_info(NAMES)\n\n\n\n\n\nPSSQLite: Insertar un registro\n\n\nFuente:\n \nPSSQLite_Ex2.ps1\n \n\n\n$Database = \n.\\Names.SQLite\n\n$query = \nINSERT INTO NAMES (Fullname, Surname, Givenname, Birthdate)\n    VALUES ('Iker', 'Landajuela', 'Popu',19790510)\n\n\nInvoke-SqliteQuery -DataSource $Database -Query $query\n\n# Leemos el contenido de la tabla\nInvoke-SqliteQuery -DataSource $Database -Query \nSELECT * FROM NAMES\n\n\n\n\n\nPodemos consultar m\u00e1s ejemplos y toda la documentaci\u00f3n en este \nenlace\n.\n\n\nCodePlex: SQLite PowerShell Provider Module\n\n\nSitio \nSQLite PowerShell Provider\n.\n\n\nAhora vamos a probar un poco el m\u00f3dulo de CodePlex.\n\n\n```\n\n\nReferencias externas\n\n\n\n\nADO.NET - MSDN - Microsoft\n.\n\n\nSQLite\n: Portal oficial.\n\n\nNuGet Command-Line Interface (CLI) Reference | Microsoft Docs\n\n\nhttps://www.nuget.org/packages/System.Data.SQLite\n\n\n3 ways to download files with PowerShell\n.\n\n\nUsing Windows PowerShell to Create BITS Transfer Jobs (Windows)\n.\n\n\nEn mi blog:\n\n\nSQLite Base de datos embebida para C\n.\n\n\nC# SQLiteBook: Catalogo de libros con SQLite (I)\n.\n\n\nC# SQLiteBook: Catalogo de libros con SQLite (II)\n.\n\n\nImport-Module - Microsoft Docs\n.\n\n\n\n\n\n\nTest-Path - Microsoft Docs\n.\n\n\n\n\nhttps://psqlite.codeplex.com/", 
            "title": "SQLite"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#systemdatasqlite-adonet", 
            "text": "System.Data.SQLite  es un proveedor ADO.NET para  SQLite . ADO.NET es un conjunto de clases que exponen servicios de acceso a datos para programadores de .NET Framework.  Para instalar el componente SQLite vamos a descargar previamente  Nuget  CLI (Command Line Interface) para usarlo desde l\u00ednea de comandos sin necesidad de usarlo desde el IDE Visual Studio ( nuget.exe Windows x86 Commandline v4.4.1 ).  Fuente:   Get-NuGet-Latest-Cli.ps1  $url =  https://dist.nuget.org/win-x86-commandline/latest/nuget.exe \n$output =  nuget.exe \n$start_time = Get-Date\n\nImport-Module BitsTransfer\nStart-BitsTransfer -Source $url -Destination $output\nWrite-Output  Time taken: $((Get-Date).Subtract($start_time).Seconds) second(s)   Ahora usando NuGet buscamos paquete:  PS  .\\nuget.exe list System.Data.SQLite  E instalamos   PS  .\\nuget.exe install System.Data.SQLite -Version 1.0.106    Nota: Hasta el momento siguiendo este m\u00e9todo no he conseguido cargara la libreria DLL usando  [System.Reflection.Assembly]::LoadFrom($SQLiteDLLPath)    Runtime  x64  y  x86 .", 
            "title": "System.Data.SQLite ADO.NET"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#pssqlite-powershell-module", 
            "text": "PSSQLite ( GitHub ) es un m\u00f3dulo de PS para trabajar con bases de datos  SQLite . Est\u00e1 disponible de forma libre en GitHub para su descarga.  Yo lo he descargado e integrado en mis fuentes con el resto de scripts, tambi\u00e9n lo he descargado comprimido como  PSSQLite-master.zip  para mantener intactos los fuentes originales (Usar sino  Install-PSSQLite.ps1  para hacerlo todo con un script).  PS  git clone https://github.com/RamblingCookieMonster/PSSQLite.git\nPS  Import-Module PSSQLite.psm1\n# Get commands in the module\nPS  Get-Command -Module PSSQLite", 
            "title": "PSSQLite PowerShell Module"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#pssqlite-creando-la-bd-y-una-tabla", 
            "text": "Fuente:   PSSQLite_Ex1.ps1    A continuaci\u00f3n vamos a crear la base de datos en el fichero  \"Names.SQLite\"  y una tabla de ejemplo.  Para importar el m\u00f3dulo  PSSQLite  he usado prestadas unas l\u00edneas de c\u00f3digo que no vienen al caso pero que se puede consultar en el script de ejemplo.   Para evitar errores primero compruebo si ya existe la BD con  Test-Path , en ese caso borro el fichero   $Database =  .\\Names.SQLite \n# Si ya existe el fichero con la BD previamente lo borramos\nif (Test-Path $Database) {Remove-Item $Database}\n\n$Query =  CREATE TABLE NAMES (\n    fullname VARCHAR(20) PRIMARY KEY, \n    surname TEXT, \n    givenname TEXT, \n    BirthDate DATETIME) \n\n# Create a database and a table\nInvoke-SqliteQuery -Query $Query -DataSource $Database\n\n# Veamos la informaci\u00f3n de la tabla recien creada\nInvoke-SqliteQuery -DataSource $Database -Query  PRAGMA table_info(NAMES)", 
            "title": "PSSQLite: Creando la BD y una tabla"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#pssqlite-insertar-un-registro", 
            "text": "Fuente:   PSSQLite_Ex2.ps1    $Database =  .\\Names.SQLite \n$query =  INSERT INTO NAMES (Fullname, Surname, Givenname, Birthdate)\n    VALUES ('Iker', 'Landajuela', 'Popu',19790510) \n\nInvoke-SqliteQuery -DataSource $Database -Query $query\n\n# Leemos el contenido de la tabla\nInvoke-SqliteQuery -DataSource $Database -Query  SELECT * FROM NAMES   Podemos consultar m\u00e1s ejemplos y toda la documentaci\u00f3n en este  enlace .", 
            "title": "PSSQLite: Insertar un registro"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#codeplex-sqlite-powershell-provider-module", 
            "text": "Sitio  SQLite PowerShell Provider .  Ahora vamos a probar un poco el m\u00f3dulo de CodePlex.  ```", 
            "title": "CodePlex: SQLite PowerShell Provider Module"
        }, 
        {
            "location": "/bases_de_datos/sqlite/sqlite/#referencias-externas", 
            "text": "ADO.NET - MSDN - Microsoft .  SQLite : Portal oficial.  NuGet Command-Line Interface (CLI) Reference | Microsoft Docs  https://www.nuget.org/packages/System.Data.SQLite  3 ways to download files with PowerShell .  Using Windows PowerShell to Create BITS Transfer Jobs (Windows) .  En mi blog:  SQLite Base de datos embebida para C .  C# SQLiteBook: Catalogo de libros con SQLite (I) .  C# SQLiteBook: Catalogo de libros con SQLite (II) .  Import-Module - Microsoft Docs .    Test-Path - Microsoft Docs .   https://psqlite.codeplex.com/", 
            "title": "Referencias externas"
        }, 
        {
            "location": "/recursos/", 
            "text": "Entornos de desarrollo\n\n\n\n\nVisual Studio Code - Code Editing. Redefined\n.\n\n\n\n\nLibros\n\n\n\n\nGitBook \ndevops-collective-inc\n: A US 501(c)(3) nonprofit dedicated to DevOps and automation education.\n\n\nThe Big Book of PowerShell Gotchas\n: PowerShell is full of \"gotchas\" - little things that just get in your way and are hard to figure out on your own. This short book is intended to help you figure them out and avoid them.\n\n\nCreating HTML Reports in PowerShell\n: Create beautiful, colorful, multi-section HTML reports from PowerShell - with very little knowledge of CSS or HTML needed!.    \n\n\n\n\n\n\nhttp://ramblingcookiemonster.github.io/Pages/PowerShellResources/index.html\n.\n\n\n\n\nCmdlets\n\n\n\n\nWindows PowerShell Cookbook\n: The following applies to example files from material published by O\u2019Reilly Media, Inc. \n\n\nCmdlet Samples\n: This section describes sample code that is provided in the Windows PowerShell 2.0 SDK.\n\n\nA Task-Based Guide to Windows PowerShell Cmdlets\n: Cmdlets are the heart-and-soul of Windows PowerShell, Microsoft's latest command shell/scripting language. \n\n\n\n\nWebs", 
            "title": "Recursos"
        }, 
        {
            "location": "/recursos/#entornos-de-desarrollo", 
            "text": "Visual Studio Code - Code Editing. Redefined .", 
            "title": "Entornos de desarrollo"
        }, 
        {
            "location": "/recursos/#libros", 
            "text": "GitBook  devops-collective-inc : A US 501(c)(3) nonprofit dedicated to DevOps and automation education.  The Big Book of PowerShell Gotchas : PowerShell is full of \"gotchas\" - little things that just get in your way and are hard to figure out on your own. This short book is intended to help you figure them out and avoid them.  Creating HTML Reports in PowerShell : Create beautiful, colorful, multi-section HTML reports from PowerShell - with very little knowledge of CSS or HTML needed!.        http://ramblingcookiemonster.github.io/Pages/PowerShellResources/index.html .", 
            "title": "Libros"
        }, 
        {
            "location": "/recursos/#cmdlets", 
            "text": "Windows PowerShell Cookbook : The following applies to example files from material published by O\u2019Reilly Media, Inc.   Cmdlet Samples : This section describes sample code that is provided in the Windows PowerShell 2.0 SDK.  A Task-Based Guide to Windows PowerShell Cmdlets : Cmdlets are the heart-and-soul of Windows PowerShell, Microsoft's latest command shell/scripting language.", 
            "title": "Cmdlets"
        }, 
        {
            "location": "/recursos/#webs", 
            "text": "", 
            "title": "Webs"
        }
    ]
}